{"meta":{"title":"Dev.liang's Blog","subtitle":"Just do it!","description":"Dev.liang's Blog - Android 技术分享、生活记录","author":"dev.liang","url":"https://leaderliang.coding.me","root":"/"},"pages":[{"title":"About Me","date":"2017-03-23T11:28:03.000Z","updated":"2019-11-08T09:28:12.125Z","comments":false,"path":"about/index.html","permalink":"https://leaderliang.coding.me/about/index.html","excerpt":"","text":"关于我身高 176cm，体重 70+kg，洛阳人，现居北京，Android 开发者一名，曾先后在支付通、学而思教育、懂球帝工作；无不良嗜好、无犯罪前科、身体健康、热爱编程和生活、为人善良淳朴、有责任心、风趣幽默且健谈。 联系我Email ：dev.liang@outlook.comGitHub：dev.liangQQ： 565100605"},{"title":"分类","date":"2019-03-11T15:27:04.000Z","updated":"2019-03-11T15:28:19.048Z","comments":false,"path":"categories/index.html","permalink":"https://leaderliang.coding.me/categories/index.html","excerpt":"","text":""},{"title":"欢迎大家给我留言，一起交流~","date":"2017-03-02T16:00:00.000Z","updated":"2019-03-11T10:18:24.891Z","comments":true,"path":"leave-a-message/index.html","permalink":"https://leaderliang.coding.me/leave-a-message/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-12T04:24:39.463Z","updated":"2019-03-12T04:24:39.463Z","comments":true,"path":"tags/index.html","permalink":"https://leaderliang.coding.me/tags/index.html","excerpt":"","text":""},{"title":"Timeline","date":"2019-03-12T05:43:37.788Z","updated":"2019-03-12T05:43:37.788Z","comments":true,"path":"timeline/index.html","permalink":"https://leaderliang.coding.me/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"网购这么多年，淘宝 | 京东 | 拼多多 | 苏宁这些大型互联网电商平台不为人知的网购黑幕你又了解多少？？","slug":"揭露-淘宝-京东-拼多多-苏宁-等大型互联网电商平台不为人知的网购黑幕","date":"2020-01-01T12:54:27.000Z","updated":"2020-06-30T06:02:09.483Z","comments":true,"path":"e6b7.html","link":"","permalink":"https://leaderliang.coding.me/e6b7.html","excerpt":"分享一些网购小常识，网购这么多年，不知道这些你的损失就太大啦…","text":"分享一些网购小常识，网购这么多年，不知道这些你的损失就太大啦… 此刻看到这篇博客的小伙伴，相信都已经具备了在淘宝、京东、拼多多等大型互联网电商平台多年的购物实战经验了吧，不瞒大家说，我也是… O(∩_∩)O 😆 常年在各大网站混的小伙伴们，一定见过类似下面的这种片儿吧： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用了 8 年的微信，都不知道的隐藏功能看了这个视频，你会回来感谢我~建议收藏备用… 本来还期待介绍个牛逼的微信功能，让我开开眼，然后情节一转，女主开始 举栗说明，她都是怎么领取 隐藏优惠券 买到李佳琪推荐的爆款口红💄，并解释 隐藏优惠券 和 返利 都是商家给的。 然后就是给你推荐 微信公众号返利机器人 或 其他微博博主 ,巴拉巴拉… 接下来的视频内容就是教你领取淘宝隐藏优惠券的教程啦~ 实际上，有的视频剧情甚至让人看了尴尬至极，其实看了视频的大多数人并不在意剧情的不适感，而是将所有注意力集中到了那个关注即可领取优惠券的 微博博主 或 公众号 身上，随手一个关注，跟着视频一顿操作后将藏在购物车中的 宝贝链接 发给 博主 or 微信机器人 (￣▽￣)” 哇！果然领到了高额的优惠券，一阵窃喜后就顺手下了单 就这样，这些博主或公众号积累了上百万的粉丝，还会时不时给你发发优惠券、抢免单等等、 为什么网购的商品会有返利佣金，购物返利是不是骗局？其实早在 2011 年底，一淘网 等返利网站已经占据了返利行业的大半壁江山，那个时候网购大军的获得返利的方式，只是通过网页进行。 一淘网，阿里巴巴旗下官方促销导购平台，成立于2010年，通过超高返利、大额红包、超值优惠券等丰富的利益点，为用户提供高性价比的品牌好货，是必不可少的网购省钱利器。 另外大部分购物返利的优惠券都来自 淘宝联盟（淘宝官方的推广平台），后来出现的第三方返利网站 / app、公众号、微博省钱博主或微信返利机器人，都是帮助商家吸引流量的一个工具（都是基于电商平台官方的返利规则接口二次开发的），包括浏览量和订单销量； 他们赚的基本上是推广的佣金，而你领的隐藏优惠券，只是推广佣金的一部分啦~ 最为关键的是，商品的成本和标价事实上是有很大差距的，也就是说商家本来就有很多的让利空间，通俗的说商家的 商品标价 可以分由三部分组成 商品成本 + 隐藏优惠券 + 推广返佣； 还有一点就是这些工具的返利形式，从 「先购物，后返利」 变成 「先送优惠，再让用户购物，同时还会有返利」，送优惠指的是通过返利平台领取 隐藏优惠券 形式（大家在淘宝对应的店铺是领取不到这样的优惠券的），商家通过这种方法给了用户确定性，降低了用户防御心理，让用户占到了便宜。 另外据统计，各大电商平台 70% 的商品都有隐藏优惠券，90% 以上的商品都有商品佣金返利！ 如果你能在购物之前就了解了这些商家的小心机，再加上有比较好的获取高额推广佣金的渠道，不开玩笑的说，你已经打败了 90% 以上的网购小伙伴。 有经验的朋友手机里可能安装了自己钟意的返利 app，但你今天看到这里不妨接着往下看，为了帮助大家更好的选择最具性价比的返利平台，为大家整理出了各大返利平台的模式对比。 各大返利平台对比分析 主要挑选了一些具有代表性的平台拿出来做对比，一目了然对于常年活跃在各大电商平台的剁手党，建议仔细看完，一年能省个 万儿八千 的不是问题！ 如果仔细看完这个完整对比分析的话，就可以看出买小道的优势啦，下面简单做下整理 永久免费升级，不收会员费，不收人头费 升级团长门槛低，轻松赚取高额佣金 团队大牛不定期分享经验，让你快速成为赚钱专家 返利产品哪家强？拿天猫旗舰店样子吸尘器做举例，淘口令如下：（可能当您复制下面这个淘口令打开淘宝查看的时候价格可能会有所变化，但是整体返利比例是一致的，以下对比仅供参考，点击可查看大图了解具体返利情况） 「好货必抢」扬子手持有线吸尘器，14000pa大吸力，轻松举提握，灵动地刷，超薄探底不卡顿!一吸即净！整屋洁净！復製这条(yePl1nvmFgH),进入「Tao宝」即可抢购「原价」159.00元「券后价」79.00元 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 买小道胜出 下面对于买小道进行一个详细的介绍，如果已经领悟到的小伙伴想直接想下载使用买小道，请点击 下载并注册买小道 买小道的四大核心亮点值得买通过大数据、人工智能的方式，监控各大电商平台，时时抓取全网商家最新优惠信息，所有的商品上架时间，都是按商家搞活动时间排序的，所以一定是最新最超值最优惠的。 商品清单App 中今日必推栏目里的商品是在系统挑选后的基础上，再通过人工仔细精心甄选而出。可以直接点击清单中喜欢的商品直接下单，也可以帮助有群的朋友无忧发群，分享到朋友圈。 自购省钱为您实时推荐全网最新物美价廉的商品并附有商家购物优惠券，下单购买不仅可以优惠而且可以得到商家的返利；即使是商家活动促销没有优惠券，下单也一样可以获得返利。 分享赚钱可以将买小道推荐给你的好友，好友成功下载买小道下单后，好友在 省钱 的基础上您也可以获得一定的 佣金 。 一句话，邀请伙伴加入买小道，省的多，同时赚的多。 小道的会员权益小道会员特权 对于普通用户注册也就是小道会员 自购省钱、分享赚钱；邀请的好友购买商品，本人享受返利； 小道团长特权 所谓小道团长，是需要在小道会员基础上完成一个晋升任务就可以享受下面的特权啦,具体的晋升任务可以在小道的 会员 界面点击 立即申请成为团长 查看哦~ 自购收益，在小道会员收益的基础上提升 30%；推广收益，在小道会员推广收益基础上提升 183%；多级团队持续收益奖励；培养团长持续返利； 小道的更多权益 小道省钱省钱小三步第一步 复制商品标题或链接第二步 打开买小道第三步 详情页领券购买 淘宝省钱攻略第一步 在淘宝内长按商品标题，点击 “复制” 或 “拷贝链接” 第二步 打开买小道 第三步 找到对应商品，领取对应的优惠券，返现金 微信省钱攻略第一步 复制淘口令 第二步 打开买小道 第三步 领取对应的优惠券，返现金 京东、拼多多、苏宁易购、唯品会等省钱攻略第一步 在京东、拼多多、苏宁易购、唯品会等电商平台手机 APP 内长按商品标题，点击 “拷贝” 或者 “复制” 第二步 打开买小道 第三步 领取对应的优惠券，返现金 啰嗦完啦，总之小道省钱只需三步呦~ 下载并注册买小道扫描下方二维码快速下载买小道 下载小道后注册时需先填写邀请码为了大家能够快速 开启省钱模式，下面送出我的邀请码~ 邀请码是买小道为会员提供的专属编码，新会员需要有老会员的邀请码推荐才可在买小道得到会员身份，并可获得新会员专享权益（新人免单等权益） 686868 686868 686868 重要的事情写三遍，哈哈哈~ 观看买小道快速上手视频 开始愉快的买买买吧~","categories":[{"name":"benefit-share","slug":"benefit-share","permalink":"https://leaderliang.coding.me/categories/benefit-share/"}],"tags":[{"name":"福利分享","slug":"benefit-share","permalink":"https://leaderliang.coding.me/tags/benefit-share/"}]},{"title":"使用 Mac 将 iPhone 数据备份到移动硬盘","slug":"使用-Mac-将-iPhone-数据备份到移动硬盘","date":"2019-11-15T12:54:27.000Z","updated":"2019-11-20T14:09:09.818Z","comments":true,"path":"3415.html","link":"","permalink":"https://leaderliang.coding.me/3415.html","excerpt":"最近用电脑备份 iphone 数据时提示我的 mac 内存不足，因为手机上的数据乱七八糟大概 100G+","text":"最近用电脑备份 iphone 数据时提示我的 mac 内存不足，因为手机上的数据乱七八糟大概 100G+； 刚好棍子节买了个硬盘，考虑把备份内容安排到我的硬盘上。我的电脑系统是 macOS Catalina 版本 10.15.1 所以这个版本用的是 Finder 来备份手机，老系统的话，还继续使用 iTunes，操作是一样的。 可以参考以下步骤 硬盘连接到 Mac 后，确保硬盘的剩余空间足够容纳 iPhone 的备份;在外置硬盘根目录新建一个名为 MobileSync 的文件夹，看好啊是根目录，在 MobileSync 下新建 Backup 的文件夹，主要是因为系统默认备份时创建的目录结构是 /Users/devliang/Library/Application\\ Support/MobileSync/Backup，这个路径是我个人电脑路径，可以类比看下自己的。打开 mac 的 Finder 找到 前往文件夹，把刚系统的备份路径复制进去打开，找到对应的备份目录，然后删除 MobileSync 下的 Backup 文件夹； 打开终端命令行执行命令 1ln -s /Volumes/Micro\\ SD/MobileSync/Backup /Users/liangyanqiao/Library/Application\\ Support/MobileSync 描述下命令行大致是这样的 ln -s 移动硬盘中的 Backup 路径 系统 MobileSync 路径注意： 文件夹路径不会操作，可以直接把文件夹拖拽到终端里即可看到路径！ 文件夹名字如果有空格的使用 \\空格 表示！ 移动硬盘名字不知道的，可以在磁盘工具里查看！ 执行命令后可以看到系统级别目录里多出一个快捷键图标的目录 Backup，然后当 Backup 下有文件的时候，实际打开的是外置硬盘的目录； 到这一步操作基本结束了，之后使用 Finder 备份的话，就会备份到新的路径上了，前提是移动设备需要提前连接上； 一些其他问题 可能出现备份过程中手机断开了，导致备份失败，下次开机后重连备份多次不成功的，极端的办法就是清除外置硬盘 Backup 文件夹下的所有文件。","categories":[{"name":"Tools","slug":"tools","permalink":"https://leaderliang.coding.me/categories/tools/"}],"tags":[{"name":"Mac","slug":"mac","permalink":"https://leaderliang.coding.me/tags/mac/"},{"name":"Tools","slug":"tools","permalink":"https://leaderliang.coding.me/tags/tools/"}]},{"title":"Kotlin 入门笔记整理","slug":"Kotlin-入门笔记整理","date":"2019-11-07T11:02:05.000Z","updated":"2019-11-08T11:04:15.586Z","comments":true,"path":"aa8e.html","link":"","permalink":"https://leaderliang.coding.me/aa8e.html","excerpt":"抽出时间把自己学习 kotlin 过程的笔记整理总结一下啦…","text":"抽出时间把自己学习 kotlin 过程的笔记整理总结一下啦…暂时先把我自己整成笔记的 PDF 贴出来。pdf 展示上还有些问题，参考了 http://lingr7.coding.me/2019/10/02/theme-hexo-pdf使用技巧-解决hexo-pdf文件显示不全的问题.html 高度还是不够，不太好哈 如果不方便也可以点击下面链接有道云笔记","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"},{"name":"Kotlin","slug":"android/Kotlin","permalink":"https://leaderliang.coding.me/categories/android/Kotlin/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://leaderliang.coding.me/tags/Kotlin/"}]},{"title":"Android 使用 Charles 抓包失败报 SSLHandshake: Received fatal alert: certificate_unknown 最有效的解决方案","slug":"使用-Charles-Android-抓包失败报-SSLHandshake-Received-fatal-alert-certificate-unknown-有效解决方案","date":"2019-08-22T03:46:10.000Z","updated":"2019-08-22T04:06:19.582Z","comments":true,"path":"adb1.html","link":"","permalink":"https://leaderliang.coding.me/adb1.html","excerpt":"Android 使用 Charles 抓取 Https 请求的报文时，Android 和 Charles 都正确安装了证书之后出现抓包失败，报错 SSLHandshake: Received fatal alert: certificate_unknown,","text":"Android 使用 Charles 抓取 Https 请求的报文时，Android 和 Charles 都正确安装了证书之后出现抓包失败，报错 SSLHandshake: Received fatal alert: certificate_unknown, 官方有个说明文档，点击查看 原因安卓7之后调整了安全策略会导致部分手机抓包失败，请参考此链接：https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html ，文中提到默认情况下，针对 API Level 24 及更高版本的应用程序不再信任用户或管理员添加的CA用于安全连接。 解决方法方法一个人手机上已经正确安装了 Charles 证书，证书不懂怎么安装的可以自行搜索。在你的 AndroidManifest.xml 文件中添加如下配置： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest ... &gt; &lt;application android:networkSecurityConfig=&quot;@xml/network_security_config&quot; ... &gt;...&lt;/application&gt;&lt;/manifest&gt; 在res目录下新建一个xml文件夹，之后在res/xml/路径下新建文件 network_security_config.xml,名字可以随意定义，路径res/xml/network_security_config.xml： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;network-security-config&gt; &lt;domain-config&gt; &lt;domain includeSubdomains=&quot;true&quot;&gt;你要抓取的域名(eg:baidu.com)&lt;/domain&gt; &lt;trust-anchors&gt; &lt;certificates src=&quot;user&quot;/&gt;//信任用户自己安装的证书 &lt;/trust-anchors&gt; &lt;/domain-config&gt;&lt;/network-security-config&gt; 方法二手机上是否有装证书也都可以使用下面的方法：在你的AndroidManifest.xml文件中添加如下配置： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest ... &gt; &lt;application android:networkSecurityConfig=&quot;@xml/network_security_config&quot; ... &gt;...&lt;/application&gt;&lt;/manifest&gt; 在res目录下新建一个xml文件夹，之后在 res/xml/ 路径下新建文件 network_security_config.xml，路径res/xml/network_security_config.xml： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;network-security-config&gt; &lt;domain-config&gt; &lt;domain includeSubdomains=&quot;true&quot;&gt;你要抓取的域名（eg:baidu.com）&lt;/domain&gt; &lt;trust-anchors&gt; &lt;certificates src=&quot;@raw/证书文件名&quot;/&gt; &lt;/trust-anchors&gt; &lt;/domain-config&gt;&lt;/network-security-config&gt; 在res目录下新建一个raw文件夹，将手机上安装的证书文件 copy 到你的工程目录，res/raw/ 目录下，证书格式：pem，crt等（chales的话就是将你在手机浏览器打开 http://charlesproxy.com/getssl 下载的证书放入即可），证书文件名，就是你放入res/raw/目录下文件的名字配置完重新运行项目，就可以看到报文了！ PS:如果配置后还是没看到 https 对应的报文，再次检查下你输入的域名，有没有带 https：//，去掉即可！","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"}]},{"title":"重逢餐厅母子惊喜相见，共品彼此最熟悉的味道","slug":"重逢餐厅母子惊喜相见，共品彼此最熟悉的味道","date":"2019-08-08T05:27:23.000Z","updated":"2019-08-08T05:32:56.257Z","comments":true,"path":"e48f.html","link":"","permalink":"https://leaderliang.coding.me/e48f.html","excerpt":"王宝强：李咏送你的项链多少钱？妈妈的回答，王宝强瞬间乐啦…","text":"王宝强：李咏送你的项链多少钱？妈妈的回答，王宝强瞬间乐啦…","categories":[{"name":"视频推荐","slug":"video","permalink":"https://leaderliang.coding.me/categories/video/"}],"tags":[{"name":"视频推荐","slug":"video","permalink":"https://leaderliang.coding.me/tags/video/"},{"name":"video","slug":"video","permalink":"https://leaderliang.coding.me/tags/video/"}]},{"title":"搭建 React Native 开发环境中遇到的问题记录","slug":"搭建-React-Native-开发环境中遇到的问题记录","date":"2019-07-02T09:20:18.000Z","updated":"2019-07-31T02:57:21.409Z","comments":true,"path":"c994.html","link":"","permalink":"https://leaderliang.coding.me/c994.html","excerpt":"最近因为工作需要在学习 React Native，过程中遇到的一些问题，简单整理一下，方便以后查阅~","text":"最近因为工作需要在学习 React Native，过程中遇到的一些问题，简单整理一下，方便以后查阅~ ，主要参考的是 React Native 中文官网的一些指南，遇到问题再针对性的解决。比如安装过程中会提示你 NVM 环境变量没配置啦，你需要按照 log 提示进行配置等诸如此类问题~ nvm，node，npm，nrm 之间的区别nvm：nodejs 版本管理工具nodejs：在项目开发时的所需要的代码库(node -v)npm：nodejs 包管理工具nrm: (npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，那么我们可以用这个来切换镜像源 You need to run “nvm install N/A” to install it before using it打开终端后一直提示这个，很烦，解决方法：查看 node 版本 node -v 执行命令： nvm ls 查看 “default” Node 版本，如果是 default -&gt; node (-&gt; N/A) 类似这样的代码，这是引起报错的原因。执行命令：nvm alias default node执行命令：nvm ls 查看展示中间可能会出现一些不能设置默认版本的，那可以再下载一个别的版本，然后再次切换。 在创建 android demo 时候，打开 app 界面很多红色背景的 log 信息可能是因为服务没有启动执行 1react-native start 如果提示什么端口被占用，还需要把占用的端口关掉 123456异常如：Metro Bundler can&apos;t listen on port 8081执行：sudo lsof -i :8081 列出占用的列表kill 查到的 对应的 pid 号 nvm 的有关命令1234567891011nvm install stable ## 安装最新稳定版 nodenvm install &lt;version&gt; ## 安装指定版本nvm uninstall &lt;version&gt; ## 删除已安装的指定版本nvm use &lt;version&gt; ## 切换使用指定的版本nodenvm ls ## 列出所有安装的版本nvm ls-remote ## 列出所有远程服务器的版本nvm current ## 显示当前的版本nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名nvm unalias &lt;name&gt; ## 删除已定义的别名nvm reinstall-packages &lt;version&gt; ## 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包nvm alias default [node版本号] ##设置默认版本 react-native 一些命令react-native link build node_modules 库react-native start 开启服务react-native run-android 编译安卓程序到手机 执行 brew install watchman 没有权限使用如下指令获取 usr/local 文件夹的写入权限sudo chown -R $(whoami) /usr/local/*重新调用 brew install watchman ，即可正常完成安装。 ‘whoami’ linux 命令，命令用于打印当前有效的用户名称，相当于执行 id -un 命令。","categories":[{"name":"React Native","slug":"react-native","permalink":"https://leaderliang.coding.me/categories/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://leaderliang.coding.me/tags/react-native/"}]},{"title":"RxJava2.0 使用过程中遇到的 bug 总结","slug":"RxJava2-0-使用过程中遇到的-bug-总结","date":"2019-06-27T10:51:50.000Z","updated":"2019-11-20T13:22:00.750Z","comments":true,"path":"a450.html","link":"","permalink":"https://leaderliang.coding.me/a450.html","excerpt":"日常开发中遇到的 RxJava2.0 问题，在这里进行一个简单的记录，也希望可以帮助到更多被这些问题困扰的小伙伴们","text":"日常开发中遇到的 RxJava2.0 问题，在这里进行一个简单的记录，也希望可以帮助到更多被这些问题困扰的小伙伴们，持续更新… io.reactivex.exceptions.UndeliverableException RxJava2 取消订阅后，抛出的异常无法捕获，导致程序崩溃： 详细异常打印日志：（io.reactivex.exceptions.UndeliverableException:The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with.） UndeliverableException 从字面意思看，意思是不可送达的异常。通过源码跟踪，发现抛出io.reactivex.exceptions.UndeliverableException 唯一地方是 RxJavaPlugins 类。 RxJava2 当取消订阅后(dispose())，RxJava 抛出的异常后续无法接收(此时后台线程仍在跑，可能会抛出IO等异常),全部由 RxJavaPlugin 接收，需要提前设置 ErrorHandler. RxJava2的一个重要的设计理念是：不吃掉任何一个异常。产生的问题是，当RxJava2“downStream”取消订阅后，“upStream”仍有可能抛出异常，这时由于已经取消订阅，“downStream”无法处理异常，此时的异常无人处理，便会导致程序崩溃。 个人出问题的代码，也是常规写法 123456789101112131415161718192021222324252627282930Observable.create((ObservableOnSubscribe&lt;HouseVOListSchema&gt;) emitter -&gt; &#123; if (isViewAttached()) &#123; try &#123; ResultBean result = apiInstance.requestData(token); if (result == null) &#123; emitter.onError(new NullPointerException()); &#125; else &#123; emitter.onNext(result); emitter.onComplete(); &#125; &#125; catch (ApiException e) &#123; Trace.e(&quot;Rxjava 接口调用异常&quot;, &quot;getSearchPageIndex123 e.getMessage() &quot;+e.getMessage() + &quot; e.getCode() &quot;+e.getCode()+&quot; e.getResponseBody() &quot; +e.getResponseBody()); emitter.onError(e); &#125; &#125;&#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // Memory leak .as(mMvpView.bindAutoDispose()) .subscribe(result -&gt; &#123; mMvpView.dismissLoading(); if (isViewAttached()) &#123; if (AppConstant.RESPONSE_RESULE_CODE == result.getCode()) &#123; mMvpView.onSuccess(result.getResult()); &#125; else &#123; mMvpView.onError(result.getMessage()); &#125; &#125; &#125;, throwable -&gt; mMvpView.onThrowable(throwable) ); 就这种常规操作的代码，出问题了。 解决方案：在 Application 初始化时候设置 RxJavaPlugin 的 ErrorHandler 123456private void setRxJavaErrorHandler() &#123; RxJavaPlugins.setErrorHandler(throwable -&gt; &#123; throwable.printStackTrace(); Trace.e(&quot;MyApplication&quot;, &quot;MyApplication setRxJavaErrorHandler &quot; + throwable.getMessage()); &#125;); &#125;","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"},{"name":"Java","slug":"java","permalink":"https://leaderliang.coding.me/categories/java/"},{"name":"RxJava","slug":"rxjava","permalink":"https://leaderliang.coding.me/categories/rxjava/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"},{"name":"Java","slug":"java","permalink":"https://leaderliang.coding.me/tags/java/"},{"name":"RxJava","slug":"rxjava","permalink":"https://leaderliang.coding.me/tags/rxjava/"}]},{"title":"Android 日常开发 bug 总结 ","slug":"Android-日常开发-bug-总结","date":"2019-06-21T11:11:23.000Z","updated":"2019-11-20T14:04:15.317Z","comments":true,"path":"484.html","link":"","permalink":"https://leaderliang.coding.me/484.html","excerpt":"日常开发中遇到的一些问题，在这里进行一个简单的记录，也希望可以帮助到更多被这些问题困扰的小伙伴们~","text":"日常开发中遇到的一些问题，在这里进行一个简单的记录，也希望可以帮助到更多被这些问题困扰的小伙伴们~ Gradle Permission denied 解决方案解决方案的地址 https://stackoverflow.com/questions/17668265/gradlew-permission-denied 输入 chmod +x gradlew 就可以解除执行权限了！","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"},{"name":"Java","slug":"java","permalink":"https://leaderliang.coding.me/categories/java/"},{"name":"RxJava","slug":"rxjava","permalink":"https://leaderliang.coding.me/categories/rxjava/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"},{"name":"Java","slug":"java","permalink":"https://leaderliang.coding.me/tags/java/"},{"name":"RxJava","slug":"rxjava","permalink":"https://leaderliang.coding.me/tags/rxjava/"}]},{"title":"Android 工程中方法数超过 65536 解决方案","slug":"Android-工程中方法数超过-65536-解决方案","date":"2019-05-16T12:10:09.000Z","updated":"2019-05-16T12:38:10.806Z","comments":true,"path":"8c75.html","link":"","permalink":"https://leaderliang.coding.me/8c75.html","excerpt":"","text":"Android Studio 错误提示 Error: null, Cannot fit requested classes in a single dex file (# methods: 66457 &gt; 65536) 解决方案build.gradle 文件 android 的 defaultConfig 里面增加 multiDexEnabled true build.gradle 文件 dependencies 里面增加 implementation ‘com.android.support:multidex:1.0.3’ Application 类中增加 kotlin 写法 1234 override fun attachBaseContext(base: Context) &#123; super.attachBaseContext(base) MultiDex.install(this)&#125; Application 类中增加 java 写法 12345@Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); &#125;","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"}]},{"title":"提升开发效率工具整理","slug":"提升开发效率工具整理","date":"2019-04-27T02:45:22.000Z","updated":"2020-03-05T13:25:28.204Z","comments":true,"path":"4794.html","link":"","permalink":"https://leaderliang.coding.me/4794.html","excerpt":"","text":"这里记录的软件和相关配置都是基于 MacOs 操作系统下… 提升开发效率工具整理APKPureAPK下载器在线极速下载原版应用 - APKPure官网,不能翻墙下载 GooglePlay 的方便啦 ScrcpyScrcpy android 客户端投屏插件 This application provides display and control of Android devices connected on USB (or over TCP/IP). It does not require any root access. It works on GNU/Linux, Windows and MacOS. 12brew install scrcpyrun: scrcpy 命令 CodotaCodota AS 快捷键，几个快捷键名字记录related symbol ，open xml source;Jump to Sourcedeclaration or usages Apple Command Line Tools 从App Store上下载的Xcode，默认是不会安装Command Line Tools的，Command Line Tools是在Xcode中的一款工具，可以在命令行中运行 C 程序。 123The bottle needs the Apple Command Line Tools to be installed.You can install them, if desired, with:xcode-select --install mac 下使用 brew 包管理工具安装 tree 相信很多使用过Linux的用户都用过 tree 命令，它可以像windows的文件管理器一样清楚明了的显示目录结构。更多可参考：https://www.jianshu.com/p/008b4c696bf1 1brew install tree 在对应某个目录下，可直接使用 tree 查看当天 目录结构； 使用 tree –help 查看更多帮助信息； MacOS 下安装 JAVA JDK 相关问题 之前安装 java jdk 都是在官网下载 pkg 包安装，有新版本然后再重新下，管理、升级和卸载起来都极不方便，另外现在直接在官网下载还是会以 0 kb 提示用户下载失败， vpn 也试了最后没成功，相较而言，使用 brew 提供自动安装和卸载的功能，管理起来也比自行安装方便轻松。如果还没用过 brew 的话可以自行 google 安装；整理借鉴：https://juejin.im/post/5d550c5d51882504fb3022f7； 如果安装最新版本的 JDK，直接执行 brew cask install java,很多时候开发环境并不一定需要最新版的 JDK 的特性，还需要在一些低版本的 JDK 基础上开发，如果使用 brew 安装其他版本的 JDK 还需要使用 homebrew-cask-versions，此命令行工具主要用于安装应用的历史版本，如果你未曾使用过则需要先进行以下的命令配置下 可能会看到类似这样的命令 brew tap caskroom/versions，这个是相对老版本的配置了，会提示 caskroom/versions was moved. Tap homebrew/cask-versions instead. 替换以下就好 1brew tap homebrew/cask-versions 可以执行 brew 的 search 命令看看有哪些 JDK 版本可供安装的：brew search java； 安装指定版本时早些日子常用 brew cask install java8 来安装，但是会提示 Error: Cask &#39;java8&#39; is unavailable: No Cask with this name exists. 可以尝试 1234567891011➜ ~ brew tap AdoptOpenJDK/openjdkUpdating Homebrew...==&gt; Tapping adoptopenjdk/openjdkCloning into &apos;/usr/local/Homebrew/Library/Taps/adoptopenjdk/homebrew-openjdk&apos;...remote: Enumerating objects: 40, done.remote: Counting objects: 100% (40/40), done.remote: Compressing objects: 100% (37/37), done.remote: Total 40 (delta 23), reused 6 (delta 0), pack-reused 0Unpacking objects: 100% (40/40), done.Tapped 26 casks (98 files, 100.6KB). 完事儿后再执行 123456789101112131415161718# 安装的就是 jdk8 最新的版本➜ ~ brew cask install adoptopenjdk8Updating Homebrew...==&gt; Downloading https://github.com/AdoptOpenJDK/openjdk8-binaries/releases/download/jdk8u232-b09/OpenJDK8U-jdk_x64_mac_hotsp==&gt; Downloading from https://github-production-release-asset-2e65be.s3.amazonaws.com/140418865/f8992f00-f3f0-11e9-951b-b9bbc######################################################################## 100.0%==&gt; Verifying SHA-256 checksum for Cask &apos;adoptopenjdk8&apos;.==&gt; Installing Cask adoptopenjdk8==&gt; Creating Caskroom at /usr/local/Caskroom==&gt; We&apos;ll set permissions properly so we won&apos;t need sudo in the future.Password:输入密码==&gt; Running installer for adoptopenjdk8; your password may be necessary.==&gt; Package installers may write to any location; options such as --appdir are ignored.installer: Package name is AdoptOpenJDKinstaller: Installing at base path /installer: The install was successful.🍺 adoptopenjdk8 was successfully installed! 安装过程可能会因为网络不稳定多次失败，多操作几次即可；执行过程中需要输入密码授权。执行过程中创建的路径/usr/local/Caskroom，对应我的电脑路径下是这样的 /usr/local/Caskroom/adoptopenjdk8/8,232:b09/OpenJDK8U-jdk_x64_mac_hotspot_8u232b09.pkg，我理解的应该会把 pkg 文件解压安装到 mac 目录/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk 下，这个 pkg 文件对应的可以删掉。 此时执行 java -version 12345➜ ~ java -versionopenjdk version &quot;1.8.0_232&quot;OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_232-b09)OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.232-b09, mixed mode) 之前在官网下载后配置效果，对比一下 12345➜ ~ java -versionjava version &quot;1.8.0_212&quot;Java(TM) SE Runtime Environment (build 1.8.0_212-b10)Java HotSpot(TM) 64-Bit Server VM (build 25.212-b10, mixed mode) 查看所有已安装的 JDK 版本路径地址：12/usr/libexec/java_home -V/usr/libexec/java_home -- v","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"},{"name":"Tools","slug":"tools","permalink":"https://leaderliang.coding.me/categories/tools/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"},{"name":"Tools","slug":"tools","permalink":"https://leaderliang.coding.me/tags/tools/"}]},{"title":"小米手机 Toast 显示带应用名称问题解决方法","slug":"小米手机Toast-显示带应用名称问题解决方法","date":"2019-04-24T06:26:46.000Z","updated":"2019-04-24T06:39:47.675Z","comments":true,"path":"e95e.html","link":"","permalink":"https://leaderliang.coding.me/e95e.html","excerpt":"","text":"小米 Toast 问题小米 青春8 手机，有不少适配问题，最令人不舒服的是 Toast 内容前带应用名称。 网上的方案网上的解决方法很多，诸如下面这种方式的很多: 12345678910private Toast toast;public void show(String text) &#123; if (toast == null) &#123; toast = Toast.makeText(this, null, Toast.LENGTH_SHORT); toast.setText(text); &#125; else &#123; toast.setText(text); &#125; toast.show();&#125; makeText() 后第二个参数为 null ，自测了下，确实是没有了烦人的应用名称。 但是如果留心看 log 日志的话，会报这样一个异常： 123456789101112131415161718192021W/System.err: java.lang.NullPointerException: Attempt to invoke interface method &apos;java.lang.String java.lang.CharSequence.toString()&apos; on a null object referenceW/System.err: at android.widget.ToastInjector.addAppName(ToastInjector.java:50)W/System.err: at android.widget.Toast.makeText(Toast.java:287)W/System.err: at android.widget.Toast.makeText(Toast.java:270)W/System.err: at com.android.rxjavaproject.MainActivity.show(MainActivity.java:105)W/System.err: at com.android.rxjavaproject.MainActivity.onCreate(MainActivity.java:98)W/System.err: at android.app.Activity.performCreate(Activity.java:7210)W/System.err: at android.app.Activity.performCreate(Activity.java:7201)W/System.err: at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1272)W/System.err: at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2926)W/System.err: at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3081)W/System.err: at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:78)W/System.err: at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:108)W/System.err: at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:68)W/System.err: at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1831)W/System.err: at android.os.Handler.dispatchMessage(Handler.java:106)W/System.err: at android.os.Looper.loop(Looper.java:201)W/System.err: at android.app.ActivityThread.main(ActivityThread.java:6806)W/System.err: at java.lang.reflect.Method.invoke(Native Method)W/System.err: at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)W/System.err: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:873) NullPointerException 异常，这样的问题是小米手机新版本系统，深度定制导致的。 个人的处理方式是这样的： 123456789public void show(String text) &#123; if (toast == null) &#123; toast = Toast.makeText(this, text, Toast.LENGTH_SHORT); toast.setText(text); &#125; else &#123; toast.setText(text); &#125; toast.show();&#125; makeText() text 参数正常设置，之后再重新 set 下，这样既保证了去掉包名，也没有任何异常。另外我们也可以尝试自定义 toast 来满足 toast 需求。","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"},{"name":"XiaoMi","slug":"android/XiaoMi","permalink":"https://leaderliang.coding.me/categories/android/XiaoMi/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"},{"name":"XiaoMi","slug":"XiaoMi","permalink":"https://leaderliang.coding.me/tags/XiaoMi/"}]},{"title":"Android 常见面试问题整理","slug":"Android-常见面试问题整理","date":"2019-04-10T13:25:29.000Z","updated":"2019-11-23T05:42:20.527Z","comments":true,"path":"242f.html","link":"","permalink":"https://leaderliang.coding.me/242f.html","excerpt":"对 Android 面试常见问题点进行总结分析，方便对碎片知识进行回顾","text":"对 Android 面试常见问题点进行总结分析，方便对碎片知识进行回顾。Android 基础常见面试问题的整理，会持续更新… Handler说下 handler 机制，Looper 通过 MessageQueue 取消息，消息队列是先进先出模式，那我延迟发两个消息，第一个消息延迟 2 个小时，第二个消息延迟 1 个小时，那么第二个消息需要等 3 个小时才能取到吗？ 参考：https://www.jianshu.com/p/558ed68d6888 MessageQueue 的实现不是队列，不要被名称迷惑，他是一个链表；每次发送消息都会按照 delay 值从小到大进行重排；所有的 delay 消息都是并行的，不是串行的；第一个延迟 2 个小时，第二个延迟 1 小时，会优先执行第二个，再过 1 小时执行第一个。 Android 为什么不能在子线程更新 UI ？谷歌提出：“一定要在主线程更新UI”，实际是为了提高界面的效率和安全性，带来更好的流畅性；反推一下，假如允许多线程更新UI，但是访问 UI 是没有加锁的，一旦多线程抢占了资源，那么界面将会乱套更新了，体验效果就不言而喻了；UI 控件是非线程安全，在多线程中并发访问可能会导致UI控件处于不可预期的状态。所以在Android中规定必须在主线程更新UI。 不对 UI 控件的访问加上锁机制的原因？上锁会让UI控件变得复杂和低效；上锁后会阻塞某些进程的执行； 在 Activity 的 onCreate 里开一个子线程更新 UI，可以运行吗？1234567891011121314151617181920public class MainActivity extends Activity &#123; private TextView tvText; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvText = (TextView) findViewById(R.id.main_tv); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; tvText.setText(&quot;OtherThread&quot;); &#125; &#125;).start(); &#125; &#125; 事件结果是可以运行。 原因如下 12345678910111213public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, HardwareRenderer.HardwareDrawCallbacks &#123; // 省略代码………………………… void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); &#125; &#125; // 省略代码…………………… &#125; ViewRootImpl 对象是在 onResume 方法回调之后才创建，那么就说明了为什么在生命周期的 onCreate() 方法里，甚至是 onResume() 方法里都可以实现子线程更新 UI，因为此时还没有创建 ViewRootImpl 对象，并不会进行是否为主线程的判断, 也就是 ViewRootImpl 的 checkThread() 会检查，而 ViewRootImpl 是在 onResume() 方法里创建。onCreate() 里还没有创建 ViewRootImpl，所以不会抛出异常。 如果耗时的话，才会抛出异常，可以尝试让线程休眠 100ms or 1000ms。","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"},{"name":"面试","slug":"interview","permalink":"https://leaderliang.coding.me/categories/interview/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"},{"name":"面试","slug":"interview","permalink":"https://leaderliang.coding.me/tags/interview/"}]},{"title":"Fragment 生命周期浅析及常见问题整理","slug":"Fragment-生命周期总结-以及常见问题整理","date":"2019-04-02T09:17:23.000Z","updated":"2019-04-02T15:59:01.715Z","comments":true,"path":"4492.html","link":"","permalink":"https://leaderliang.coding.me/4492.html","excerpt":"平时项目中少不了 Fragment 的使用，也会遇到一些奇怪的问题，今天抽时间对 Fragment 的生命周期，奇葩问题进行一个稍微全面的总结","text":"平时项目中少不了 Fragment 的使用，也会遇到一些奇怪的问题，今天抽时间对 Fragment 的生命周期，奇葩问题进行一个稍微全面的总结 。官方指南 Fragment 各个生命周期作用和拓展Fragment 各个生命周期介绍先上两张官方图，左侧 Activity 和 Fragment 生命周期对比，右侧是 Fragment 生命周期。 onAttach()执行该方法时，Fragment 与 Activity 已经完成绑定，onAttach (Activity activity) 该方法有一个 Activity 类型的参数，代表绑定的 Activity，这时候你可以根据需要进行 mActivity = activity 赋值操作。 拓展：Fragment 关联到 Activity 时的回调，此时 Activity 已经与 Fragment 关联，通过 Context 向下转型，就可以与 Activity 通信当然也可以使用 getActivity(),前提是这个 fragment 已经和宿主的 activity 关联，并且没有脱离。onAttach 只调用一次。 onCreate()初始化Fragment。可通过参数 savedInstanceState 获取之前保存的值。 拓展：系统创建 Fragment 的时候回调，介于 onAttach() 和 onCreateView() 之间，一般用于初始化一些数据，需要注意的是，此时 Activity 还在创建中，因此不能在执行一些跟 Activity UI 相关的操作，否则会出现一些难以预料的问题，如NullPointException 如果要对 Activity 上的 UI 进行操作，可在 onActivityCreated() 中操作。 onCreateView()初始化 Fragment 的布局。加载布局和 findViewById 的操作通常在此函数内完成，但是不建议执行耗时的操作，比如读取数据库数据列表。 拓展：创建 Fragment 需要显示的 View，默认返回 null。当返回的 View 不为 null 时，View 被销毁时会调用onDestroyView()，此处应该只进行布局的初始化，而不应该执行耗时操作，如网络请求、数据库读取等。另外有时候 onCreateView 会被多次调用, 可以把初始化布局、view 的过程放在 onCreate 中，onCreateView 中直接 return View 对象即可。 onActivityCreated()执行该方法时，与 Fragment 绑定的 Activity 的 onCreate 方法已经执行完成并返回，在该方法内可以进行与 Activity 交互的 UI 操作，所以在该方法之前 Activity 的 onCreate 方法并未执行完成，如果提前进行交互操作，会引发空指针异常。 拓展：当 Activity 执行完 onCreate() 方法后会被调用，此时可以执行与 Activity 相关的 UI 操作 onSaveInstanceState()保存当前Fragment的状态。该方法会自动保存Fragment的状态，比如EditText键入的文本，即使Fragment被回收又重新创建，一样能恢复EditText之前键入的文本。 ###### ----------------------------- 以下几个跟 Activity 中对应方法类似 start ---------------------------- onStart()执行该方法时，Fragment 由不可见变为可见状态。 onResume()执行该方法时，Fragment 处于活动状态，用户可与之交互。 onPause()执行该方法时，Fragment 处于暂停状态，但依然可见，用户不能与之交互。 onStop()执行该方法时，Fragment 完全不可见。 —————————– 以上几个跟 Activity 中对应方法类似 end —————————- onDestroyView()销毁与 Fragment 有关的视图，但未与 Activity 解除绑定，依然可以通过 onCreateView 方法重新创建视图。通常在ViewPager + Fragment 结合使用时会调用此方法。 拓展：表示销毁 Fragment 相关联的 UI 布局，清除所有跟视图相关的资源。不一定在 Activity 的 onDestroy() 方法中调用。 onDestroy()销毁 Fragment。通常按 Back 键退出或者 Fragment 被回收时调用此方法。 拓展：销毁 Fragment 对象的时候调用，一般是调用 Activity 的 onDestroy() 的时候执行。 onDetach()解除与 Activity 的绑定（解除 Fragment 与 Activity 的关联）。在 onDestroy 方法之后调用。 setUserVisibleHint()设置Fragment可见或者不可见时会调用此方法。在该方法里面可以通过调用 getUserVisibleHint() 获得 Fragment 的状态是可见还是不可见的，如果可见则进行懒加载操作。 拓展：当 Fragment 与 ViewPager 结合使用时，切换 Pager 时回调方法。 ### ViewPager 切换 Fragment 相关生命周期 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// Fragment 初始化创建04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: setUserVisibleHint04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onAttach04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onCreate04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onCreateView04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onActivityCreated04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onStart04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onResume// Fragment变为不可见状态// 屏幕锁屏、回到桌面、被Activity完全覆盖 经历一样的生命周期04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onPause04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onSaveInstanceState04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onStop// 屏幕解锁04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onStart04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onResume// 切换到其他 Fragment04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onPause04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onStop04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onDestroyView// 切换回本身的 Fragment04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onCreateView04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onActivityCreated04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onStart04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onResume// 回到应用04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onStart04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onResume// Fragment 退出（注意退出不会调用onSaveInstanceState方法，因为是人为退出，没有必要再保存数据）04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onPause04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onStop04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onDestroyView04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onDestroy04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onDetach// Fragment变为部分可见状态（打开Dialog样式的Activity）04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onPause04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onSaveInstanceState// Fragment 由不可见变为活动状态04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onStart04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onResume// Fragment由部分可见变为活动状态04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onResume// Fragment 被回收又重新创建// 被回收执行04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onPause04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onSaveInstanceState04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onStop04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onDestroyView04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onDestroy04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onDetach// 重新创建执行04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onAttach04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onCreate04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onCreateView04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onActivityCreated04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onStart04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: onResume04-02 21:24:48.240 2049-2448/? I/Fragment Lifecycle: setUserVisibleHint// 横竖屏切换：与Fragment被回收又重新创建一样。 ### **补充** onAttach() 和 onCreate() 只在 Fragment 与 Activity 第一次关联时调用。 onDestroy() 和 onDetach() 只在 Fragment 的宿主 Activity 销毁时才会被调用。 根据前 2 点，将 Fragment 通过 addToBackStack() 只涉及 onCreateView() 和 onDestroyView() 这之间的生命周期。add() 和 replace() 不会对 Fragment 的生命周期产生影响，但 add() 方法会造成 Fragment 叠加显示。 Fragment 与 ViewPager 结合使用时的生命周期与第 3 点相似。 通过 hide() 、show() 来隐藏、显示Fragment，此时 Fragment 只改变了可见性，并不涉及生命周期的改变。 不要在 Fragment 的 onCreate() 方法中操作宿主 Activity 的 UI。因为无法保证此时宿主 Activity 的 UI 已经完全初始化，某些情况下也是可以确保宿主 Activity 已经初始化完成的。 onViewCreated() 该方法在 onCreateView() 之后会被立即执行，此时可以对 View 对象进行赋值，onCreateView 是创建的时候调用，onViewCreated 是在 onCreateView 后被触发的事件，前后关系。 Fragment 中有几个比较相似的生命周期方法 onCreate、onCreatView、onViewCreated，需要仔细区分一下。 12345678/** * Called immediately after onCreateView(android.view.LayoutInflater, android.view.ViewGroup, * android.os.Bundle) has returned, but before any saved state has been restored in to the view. * This gives subclasses a chance to initialize themselves once they know their view hierarchy has * been completely created. The fragment&apos;s view hierarchy is not however attached to its parent at * this point. */void onViewCreated(View view, Bundle savedInstanceState) 官方的一段介绍， onCreateView 是创建的时候调用，onViewCreated 会在 onCreateView 被触发后调用，前后关系；也是 fragment 中的 onCreateView 和 onViewCreated 的区别和联系。另外 onStart 运行时间位于 onViewCreated 之后。 Fragment 相关奇葩问题整理onCreateView（）调用多次？遇到在滑动 Fragment 的过程中不断重复调用 onCreateView 的问题，导致控件不断初始化，影响程序的整体逻辑。可以尝试把初始化操作写在 OnCreate() 中，是为了控件只初始化一次。oncreateView 会被多次执行。 另一种方案： private View mView; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { if (null != mView){ ViewGroup parent = (ViewGroup) mView.getParent(); if (null != parent) { parent.removeView(mView); } }else { mView = inflater.inflate(R.layout.main_layout, container, false); // 初始化 View， findViewById(); } return mView; }setUserVisibleHint() 不被调用？通常情况下都是因为继承的是 PagerAdapter 而不是 FragmentPagerAdapter 造成的，FragmentPagerAdapter 内部实现了对setUserVisibleHint()方法的调用，所以需要懒加载的结构最好使用 FragmentPagerAdapter + Fragment 的结构，少用PagerAdapter。 FragmentStatePagerAdapter 和 FragmentPagerAdapter 区别？FragmentPagerAdapter 是另一种可用的 PagerAdapter，其用法和 FragmentStatePagerAdapter 基本一致，只是在卸载不需要的 fragment 时，各自采用的处理方法不同。 FragmentStatePagerAdapter 会销毁不需要的 fragment，而 FragmentPagerAdapter 是调用 detach(Fragment) 方法来处理它，只是销毁了 fragment 的视图，而 fragment 的实例由 FragmentManager 维护，因此，FragmentPagerAdapter 创建的 fragment 永远不会被销毁。 所以当数据量大时，可以选择 FragmentStatePagerAdapter，用户界面只有少量固定的 fragment 时，可以选择 FragmentPagerAdapter。 FragmentPagerAdapter+ViewPager 的注意事项 ?使用 FragmentPagerAdapter + ViewPager 时，切换回上一个 Fragment 页面时（已经初始化完毕），不会回调任何生命周期方法以及onHiddenChanged()，只有 setUserVisibleHint(boolean isVisibleToUser)会被回调，所以如果你想进行一些懒加载，需要在这里处理。 在给ViewPager绑定FragmentPagerAdapter时，new FragmentPagerAdapter(fragmentManager)的FragmentManager，一定要保证正确，如果ViewPager是Activity内的控件，则传递getSupportFragmentManager()，如果是Fragment的控件中，则应该传递getChildFragmentManager()。只要记住ViewPager内的Fragments是当前组件的子Fragment这个原则即可。 你不需要考虑在“内存重启”的情况下，去恢复的Fragments的问题，因为FragmentPagerAdapter已经帮我们处理啦。 未完待更新…未完待更新…","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"},{"name":"Fragment","slug":"fragment","permalink":"https://leaderliang.coding.me/tags/fragment/"}]},{"title":"Design Patterns in Android","slug":"Design-Patterns-in-Android","date":"2019-03-23T14:51:06.000Z","updated":"2019-12-19T02:40:45.303Z","comments":true,"path":"ebf2.html","link":"","permalink":"https://leaderliang.coding.me/ebf2.html","excerpt":"对日常在 Android 中实用设计模式进行一下梳理和总结","text":"对日常在 Android 中实用设计模式进行一下梳理和总结，文中参考了一些网站和大佬的博客，如 MichaelX（xiong_it） 、菜鸟教程、四月葡萄、IAM四十二等，在这里注明下~另外强烈推荐图说设计模式，看了一部分，有些介绍的还是很通俗易懂的。 设计模式（持续更新ing…）单例模式 (Singleton pattern)确保一个类只有一个实例，并且自行实例化并向整个系统提供这个实例(并提供对该实例的全局访问) 饿汉式、懒汉式名词解释：饿汉式：不管程序是否需要这个对象的实例，总是在类加载的时候就先创建好实例，理解起来就像不管一个人想不想吃东西都把吃的先买好，如同饿怕了一样。 1234567891011121314/** * 饿汉式 */public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 优点：写法简单，线程安全。 缺点：没有懒加载的效果，如果没有使用过的话会造成内存浪费 懒汉式：如果一个对象使用频率不高，占用内存还特别大，明显就不合适用饿汉式了，这时就需要一种懒加载的思想，当程序需要这个实例的时候才去创建对象，就如同一个人懒的饿到不行了才去吃东西。 12345678910111213141516171819202122232425262728/** * 懒汉式 */public class Singleton &#123; /** * volatile 关键字修饰的变量，一次只能有一个线程操作该变量，保证线程安全 * volatile 能够防止代码的重排序，保证得到的对象是初始化过 */ private volatile static Singleton mSingleton; private Singleton ()&#123; &#125; /** * 双重校验锁模式 */ public static Singleton getSingleton() &#123; if (mSingleton == null) &#123; // 第一次检查，避免不必要的同步 synchronized (Singleton.class) &#123; // 同步 if (mSingleton == null) &#123; // 第二次检查，为null时才创建实例 mSingleton = new Singleton(); &#125; &#125; &#125; return mSingleton; &#125; &#125; 优点：懒加载，线程安全，效率较高 缺点：volatile 影响一点性能，高并发下有一定的缺陷，某些情况下 DCL 会失效，虽然概率较小 volatile 关键字修饰的变量，一次只能有一个线程操作该变量，保证线程安全。 为什么要在变量 singleton 加上 volatile 关键字？要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤： 分配内存空间 初始化对象 将内存空间的地址赋值给对应的引用 但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程： 分配内存空间 将内存空间的地址赋值给对应的引用 初始化对象 如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。 双重校验锁中两个 if 判断的作用？第一：是为了提高程序的 效率，当 Singleton 对象被创建以后，再获取 Singleton 对象时就 不用去验证同步代码块的锁及后面的代码，直接返回Singleton 对象。第二：是为了解决多线程下的安全性问题，也就是保证对象的唯一。如果没有第二个 if 判断，A、B两个线程，A 先执行， 线程 B 再进入 synchronized (instance)块，不用去验证instance 是否为 null，就会直接创建一个 Singleton 新对象，这样整个程序运行下来就有可能创建多个实例。 注意：如果处于多线程环境，注意保持线程安全，不然就无法保证单例了；单例模式的默认构造方法的修饰符需改为 private，只能类内部访问，确保外部不能直接 new 出该实例；单例模式需要提供一个全局访问入口，这个入口通常以 getInstance() 的 public 静态方法形式呈现。 简单工厂模式 (Simple Factory Pattern ) 更多详细介绍工程模式，可链接查看 四月葡萄 定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的初始化下放到子类。 生成复杂对象时，确定只有一个工厂类，可以使用简单工厂模式。否则有多个工厂类的话，使用工厂方法模式。 优点代码解耦，创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建。 缺点违背开放封闭原则，若需添加新产品则必须修改工厂类逻辑，会造成工厂逻辑过于复杂。简单工厂模式使用了静态工厂方法，因此静态方法不能被继承和重写。工厂类包含了所有实例（产品）的创建逻辑，若工厂类出错，则会造成整个系统都会会受到影响。 Android 开发中的工厂模式实践场景：项目中使用了 Universal Image Loader作为图片加载框架，过一段时间后，发现 UIL 已经不流行了，想用更加 fashion的 Glide 来代替 UIL，再或者有一天，Glide 不更新，也不 fashion 了… 难道又要换其他图片加载框架？难道又改吗？？？这个时候，工厂方法可能可以帮上忙：使用工厂类隔离图片加载的具体实现，对外只暴露一个工厂方法用来外部生产想要的加载框架实例，就可避免上述提到的尴尬。 图片加载接口 1234567891011/** * 图片加载接口 */public interface ImageLoaderInterf &#123; interface CallBack &#123; void onSuccess(Bitmap result); void onFailure(); &#125; void load(Context context, String imgUrl, ImageView view);&#125; 图片加载工厂类 123456789101112131415161718public class ImgLoaderClientFactory &#123; public static final GLIDE = 0; public static final UIL = 1; public static final PICASSO = 2; public static ImageLoaderInterf getImageLoaderClient(int type) &#123; switch (type) &#123; case GLIDE: return GlideClient.getInstance(); case UIL: return UilClient.getInstance(); default: return PicassoClient.getInstance(); &#125; &#125;&#125; UilClient：Universal Image Loader封装 1234567891011121314151617181920public class UilClient implements ImageLoaderInterf &#123; private static UilClient sInstance; private UilClient() &#123;&#125; public static UilClient getInstance() &#123; synchronized (UilClient.class) &#123; if (sInstance == null) &#123; sInstance = new UilClient(); &#125; &#125; return sInstance; &#125; @Override public void load(Context context, String imgUrl, ImageView view) &#123; ImageLoader.getInstance().displayImage(imgUrl, view); &#125;&#125; GlideClient：Glide的二次封装 12345678910111213141516171819public class GlideClient implements ImageLoaderInterf &#123; private static GlideClient sInstance; private GlideClient() &#123;&#125; public static GlideClient getInstance() &#123; synchronized (GlideClient.class) &#123; if (sInstance == null) &#123; sInstance = new GlideClient(); &#125; &#125; return sInstance; &#125; @Override public void load(Context context, String imgUrl, ImageView view) &#123; Glide.with(context).load(imgUrl).into(view); &#125;&#125; PicassoClient：Picasso封装类 123456789101112131415161718192021public class PicassoClient implements ImageLoaderInterf &#123; private static PicassoClient sInstance; private PicassoClient() &#123; &#125; public static PicassoClient getInstance() &#123; synchronized (PicassoClient.class) &#123; if (sInstance == null) &#123; sInstance = new PicassoClient(); &#125; &#125; return sInstance; &#125; @Override public void load(Context context, String imgUrl, ImageView view) &#123; Picasso.with(context).load(imgUrl).into(view); &#125;&#125; 那么加载图片设置就变成了下面这样： 1ImgLoaderClientFactory.getImageLoaderClient(ImgLoaderClientFactory.UIL).load(mContext, imgUrl, imageView); 要切换图片框架呢？怎么办？可以单独写一个变量通过赋值，全局使用，或者 全局搜索替换 ImgLoaderClientFactory.UIL 也行，比如想切到Glide，将用到 ImgLoaderClientFactory.UIL 地方改成 ImgLoaderClientFactory.GLIDE 即可。 1ImgLoaderClientFactory.getImageLoaderClient(ImgLoaderClientFactory.GLIDE).load(mContext, imgUrl, imageView); 策略模式 (Strategy pattern)定义一组算法，将其各个封装，并且使他们有交换性 策略模式好处在于使得算法在用户使用的时候能独立的改变，单一的修改，并且有良好扩展性。 算法：指的是各个策略的实现逻辑，而非算法领域的数据算法。 优点 策略类可以互相替换由于策略类都实现同一个接口，因此他们能够互相替换。 耦合度低，方便扩展增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合开闭原则。 避免使用多重条件选择语句（if-else或者switch）。 缺点 策略的增多会导致子类的也会变多 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 UML 类图 策略模式各角色讲解：Strategy：策略基类（接口或者抽象类再或者抽象策略类），定义子策略需要实现的方法，比如 algorithm()，该方法取决于客户端代码（高层代码）需要该策略实现什么功能，子类则实现该方法，封装自己的算法，供外部调用。Context：此 Context，非彼（Android中的）Context，它持有 Strategy 真实的实例对象，提供给客户端调用 Strategy 时的上下文调度者。ConcreteStrategyA：实现父类 Strategy 的方法，封装自身算法逻辑。ConcreteStrategyB：同上 例子：一个加减乘除的策略，定义一个 Strategy 接口，然后针对接口实现对应的加减乘除的实体策略类。 android 中的策略模式应用实践：需求：接入微信支付，支付宝支付，银联支付等移动端通用支付方式。 以下是大致实现： PayActivity：客户端角色，支付方式选择界面 AbsPayStrategy：作为支付策略基类，定义了一个pay方法 PayContext：上下文角色，用来封装支付AbsPayStrategy对象 WeChatPayStrategy：封装了微信支付算法逻辑 ALiPayStrategy：封装了支付宝支付算法逻辑 BankCardPayStrategy：封装了银行卡支付算法逻辑 支付功能的示意代码：AbsPayStrategy的实际实现应该为抽象类，它需要持有Activity对象。 12345public interface AbsPayStrategy &#123; // private Activity mActivity; // 本策略主要就是实现支付功能 void pay();&#125; Context 上下文角色 1234567891011public class PayContext &#123; private AbsPayStrategy mPayStrategy; public PayContext(AbsPayStrategy payStrategy) &#123; mPayStrategy = payStrategy; &#125; public void pay() &#123; mPayStrategy.pay(); &#125;&#125; 微信支付策略实现 123456789/** * 微信支付策略 */public class WeChatPayStrategy implements AbsPayStrategy &#123; public void pay() &#123; // 此处封装微信支付逻辑 &#125;&#125; 支付宝支付策略实现 123456789/** * 支付宝支付策略 */public class ALiPayStrategy implements AbsPayStrategy &#123; public void pay() &#123; // 此处封装支付宝支付逻辑 &#125;&#125; 具体的客户端代码，此处为PayActivity 123456789101112131415161718192021222324public class PayActivity extends Activity implements View.OnclickListener&#123; private PayContext mPayContext; @Override public void onClick(View view) &#123; switch(v.getId()) &#123;// 客户端来决定使用哪种支付策略 case R.id.wechat_pay: mPayContext = new PayContext(new WechatPayStrategy()); break; case R.id.wechat_pay: mPayContext = new PayContext(new ALiPayStrategy()); break; case R.id.wechat_pay: mPayContext = new PayContext(BankCardPayStrategy()); break; default: mPayContext = new PayContext(new WechatPayStrategy()); break; &#125; // 利用实际的支付策略对象进行支付 mPayContext.pay(); &#125; &#125; 这样就实现了一个 app 内的支付功能，如果微信支付出现问题了，改动微信支付策略代码，支付宝支付出现问题，改动想要实现即可，职责单一。如果PM有一天说：我们需要接入更多支付，怎么办？ 简单啊，实现相应的支付策略即可，完美适应需求变更，实现功能扩展。 观察者模式 (Observer pattern)定义定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 介绍观察者模式属于（对象）行为型模式。观察者模式又被称作发布/订阅模式。观察者模式主要用来解耦，将被观察者和观察者解耦，让他们之间没有没有依赖或者依赖关系很小。 优点解除观察者与主题之间的耦合。让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。易于扩展，对同一主题新增观察者时无需修改原有代码。 缺点依赖关系并未完全解除，抽象主题仍然依赖抽象观察者。使用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。可能会引起多余的数据通知 UML 策略模式各角色说明：Subject（抽象主题）：又叫抽象被观察者，把所有观察者对象的引用保存到一个集合里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。ConcreteSubject（具体主题）：又叫具体被观察者，将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。Observer (抽象观察者):为所有的具体观察者定义一个接口，在得到主题通知时更新自己。ConcrereObserver（具体观察者）：实现抽象观察者定义的更新接口，当得到主题更改通知时更新自身的状态。 java 代码实现创建抽象观察者1234567891011/** * TODO Observer (抽象观察者):为所有的具体观察者定义一个接口，在得到主题通知时更新自己。 * 定义一个接到通知的更新方法，即收件人收到通知后的反应 * * @author dev.liang &lt;a href=&quot;mailto:dev.liang@outlook.com&quot;&gt;Contact me.&lt;/a&gt; * @version 1.0 * @since 2019/03/24 16:29 */public interface Observer &#123; void update(String msg);&#125; 创建具体观察者1234567891011121314151617181920/** * TODO （具体观察者）：实现抽象观察者定义的更新接口，当得到主题更改通知时更新自身的状态。 * * @author dev.liang &lt;a href=&quot;mailto:dev.liang@outlook.com&quot;&gt;Contact me.&lt;/a&gt; * @version 1.0 * @since 2019/03/24 16:55 */public class ConcreteObserver implements Observer &#123; String mObserverName; public ConcreteObserver(String mObserverName) &#123; this.mObserverName = mObserverName; &#125; @Override public void update(String msg) &#123; System.out.println(&quot;具体观察者&quot; + mObserverName + &quot;,收到了信息:&quot; + msg); &#125;&#125; 创建抽象主题12345678910111213141516171819202122232425262728293031323334/** * TODO * Subject（抽象主题）： * 又叫抽象被观察者，把所有观察者对象的引用保存到一个集合里， * 每个主题都可以有任何数量的观察者。 * 抽象主题提供一个接口，可以增加和删除观察者对象。 * * @author dev.liang &lt;a href=&quot;mailto:dev.liang@outlook.com&quot;&gt;Contact me.&lt;/a&gt; * @version 1.0 * @since 2019/03/24 16:11 */public interface Subject &#123; /** * 添加观察者 * * @param observer */ void attach(Observer observer); /** * 删除观察者 * * @param observer */ void detach(Observer observer); /** * 通知观察者 * * @param msg */ void notify(String msg);&#125; 创建具体主题12345678910111213141516171819202122232425262728293031323334/** * subscribe * TODO ConcreteSubject（具体主题）： * 又叫具体被观察者，将有关状态存入具体观察者对象； * 在具体主题内部状态改变时，给所有登记过的观察者发出通知. * * @author dev.liang &lt;a href=&quot;mailto:dev.liang@outlook.com&quot;&gt;Contact me.&lt;/a&gt; * @version 1.0 * @since 2019/03/24 16:34 */public class ConcreteSubject implements Subject&#123; private List&lt;Observer&gt; observerList = new ArrayList(); @Override public void attach(Observer observer) &#123; observerList.add(observer); &#125; @Override public void detach(Observer observer) &#123; observerList.remove(observer); &#125; @Override public void notify(String msg) &#123; /*循环通知收件人（观察者）*/ if(!CollectionUtils.isEmpty(observerList)) &#123; for (Observer observer : observerList) &#123; observer.update(msg); &#125; &#125; &#125;&#125; 测试12345678910111213public class ObserverTest &#123; public static void main(String[] str) &#123; ConcreteSubject concreteSubject = new ConcreteSubject(); Observer observerLiang = new ConcreteObserver(&quot;老梁&quot;); Observer observerWang = new ConcreteObserver(&quot;老王&quot;); concreteSubject.attach(observerLiang); concreteSubject.attach(observerWang); concreteSubject.notify(&quot;今天发工资~&quot;); /*老梁没发工资*/ concreteSubject.detach(observerLiang); concreteSubject.notify(&quot;发了工资~&quot;); &#125;&#125; 打印123具体观察者老梁,收到了信息:发工资啦~具体观察者老王,收到了信息:发工资啦~具体观察者老王,收到了信息:发了工资~ Android 中的观察者模式控件中Listener监听方式Adapter的notifyDataSetChanged()方法BroadcastReceiverBroadcastReceiver 作为 Android 的四大组件之一,实际上也是一个典型的观察者模式.通过 sendBroadcast 发送广播时,只有注册了相应的 IntentFilter 的 BroadcastReceiver 对象才会收到这个广播信息,其onReceive方法才会被调起。 代理模式（Proxy Pattern）为目标对象提供一种代理，客户端通过代理去访问目标对象。 前提：如果从写代码的角度出发，当我们遇到以下场景： 无法直接访问某个对象 不想直接访问某个对象 访问某个对象存在困难 的时候，我们就可以通过一个代理，通过它来间接访问真正的对象。 UML 图 从代理模式的 UML 类图中，我们可以得到如下结论： 代理对象和委托对象需要实现相同的接口（抽象类）; 代理对象持有委托对象的引用; 可以看到，代理模式非常简洁，总共就三个角色，包括抽象主题，委托者和代理者。用代码实现以下代理模式。 1234567891011121314151617181920212223242526272829303132333435363738394041public interface Subject &#123; void doSomething();&#125;/** * 委托类 */public class RealSubject implements Subject &#123; @Override public void doSomething() &#123; System.out.println(&quot;This is real doSomeThing&quot;); &#125;&#125;/** * 代理类 */public class ProxySubject implements Subject &#123; private Subject mSubject; // 代理类持有委托类的引用 public ProxySubject(Subject realSubject) &#123; mSubject = realSubject; &#125; @Override public void doSomething() &#123; mSubject.doSomething(); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; //创建委托类 Subject mRealSubject=new RealSubject(); //创建代理类 ProxySubject mProxy = new ProxySubject(mRealSubject); //由代理类去做具体的操作 mProxy.doSomething(); &#125;&#125; 可以看到 RealSubject 和 ProxySubject 都实现了接口 Subject。在客户端使用ProxySubject 的实例调用 doSomething() 方法，而不是使用 RealSubject 的实例来实现。 你可能会好奇，这么做的意义是什么呢？直接用 RealSubject 的实例来调用 doSomething 方法不也可以吗？何必多此一举。试想，如果现在有很多个委托类，他们各自的实现都不同，客户端只关心doSomething 的调用，而不关心具体的实现，这样代理类就可以在其内部屏蔽委托类之间的差异了，这也是客户端不想关注的事情。 动态代理以上的分析中，代理类是由我们直接创建好的；现实中可能还有这样一种场景，代理类并不是在程序编译的时候创建，而是在运行的过程中通过Java的反射机制动态的进行创建，这样的代理模式成为动态代理，对应的之前我们所说的就是静态代理了。 其实，动态代理的实现没有什么可说的，说白了都是模板代码，Java为开发者提供了InvocationHandler,实现该接口重写其invoke 方法即可。 代码示例可在 Github 上查看。 在 Android 中，关于动态代理的使用，最经典的就是 Retrofit 了。这里可以简单看一下。 123456789/** * 声明自己的网络请求接口 */public interface GithubService &#123; @GET(&quot;/users/leaderliang/repos&quot;) Call&lt;List&lt;Repo&gt;&gt; getUserRepos();&#125; 初始化 Retrofit，发起网络请求 123456789101112131415161718Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://api.github.com&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); GithubService mGithubService = retrofit.create(GithubService.class);Call&lt;List&lt;Repo&gt;&gt; repos = mGithubService.getUserRepos();repos.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() &#123; @Override public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) &#123; System.out.println(response.code() + &quot; &quot; + new Gson().toJson(response.body())); &#125; @Override public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) &#123; Toast.makeText(MainActivity.this, &quot;onFailure&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;); 上面代码使用过 Retrofit 的应该熟悉吧。当我们用 Retrofit 实例，调用其 create 方法时，发现就已经帮我们做好了 GithubService 的实现，发生了什么呢？下面是 creat 示例代码： 123456789101112131415161718192021222324public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; // new Class&lt;?&gt;[] &#123; service &#125; 声明了 service，但是我们需要知道这个过程是怎么去实现的。 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); &#125; &#125;); &#125; create（） 方法里的 1return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123;&#125;); 实际体现的就是动态代理的整个过程，这个 return 就相当于动态创建了 ProxyService 这个代理类，写一段伪代码，应该可以帮助进一步理解了： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ProxyService implements GithubService &#123; InvocationHandler invocationHandler = new InvocationHandler() &#123; private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); &#125; &#125;; @Override public Call&lt;List&lt;Repo&gt;&gt; getUserRepos() &#123; try &#123; Method method = GithubService.class.getMethod(&quot;getUserRepos&quot;); return (Call&lt;List&lt;Repo&gt;&gt;) invocationHandler.invoke(this, method, null); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; return null; &#125; /** * 其他接口 */ @Override public Call&lt;User&gt; getOtherMethod()&#123; //... return ...; &#125;&#125; 可以看到，这里就是一个典型的动态代理实现，通过serviceMethod.callAdapter.adapt返回了一个service对象的代理对象，在上面的例子里，就是返回了一个GitHubService的代理对象，这样我们就可以通过这样一个对象去调用GitHubService中定义好的各种网络请求，而不用在使用的时候再去决定是POST请求还是GET请求,参数是放在Body里还是params里，因为Retrofit 通过把反射注解和动态代理的巧妙结合，屏蔽了复杂的参数拼接操作，把所有我们需要对OKHttp的进行传递的参数，动态的帮我们传递了，一旦在接口中定义好了使用方式，就可以非常方便的获取到okhttp中最关键的Call了，有了Call我们就可以通过execute或者是enqueue发起网络请求了。 以上就是对代理模式的分析，总的来说代理模式的结构非常简单；包括抽象主题，委托类，代理类三个核心角色，从大的方向上可以分为静态代理和动态代理两大类；通过静态代理的方式，在开发迭代的过程中，为实现兼容性提供了一种非常友好的实现思路；在日常开发中，如果我们使用的对象之间有着强烈的耦合，可是思考一下是否可以通过代理模式解耦；同时，当我们需要扩展某个类的部分功能时，但又不想去破坏原有的功能或者是根本无法修改时，我们可以考虑代理模式，但也要明白，通过代理模式我们能做的也只能是功能扩展，想要更新委托类中已经实现的内容他是无能为力的。 动态代理，可以根据运行时的委托类动态的生成代理类，这样就减轻了代理类的负担，避免在编码阶段就具体的委托类再做各种判断了。 代理模式很简单，也很实用，但不要忘记代理类和委托类需要实现功能的接口或抽象类，不要忽略了这一点。 参考链接：https://juejin.im/post/5a4e4725f265da3e2c37e36e","categories":[{"name":"设计模式","slug":"design-patterns","permalink":"https://leaderliang.coding.me/categories/design-patterns/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"},{"name":"设计模式","slug":"design-patterns","permalink":"https://leaderliang.coding.me/tags/design-patterns/"}]},{"title":"P2P 投资交流之荷包金融","slug":"P2P-投资交流之荷包金融","date":"2019-03-18T07:58:37.000Z","updated":"2019-11-26T08:59:28.156Z","comments":true,"path":"128b.html","link":"","permalink":"https://leaderliang.coding.me/128b.html","excerpt":"荷包金融投资的小伙伴可以看过来了，为了方便大家交流，在这里创建了 QQ 和微信群组，喷子、广告勿加….","text":"荷包金融投资的小伙伴可以看过来了，为了方便大家交流，在这里创建了 QQ 和微信群组，喷子、广告勿加….我作为荷包的投资者，建群目的也是为了让大家更多的去了解荷包的相关资讯，目前平台在政府的帮助下，在逐步的开始兑付工作，请大家不信谣不传谣，积极面对！ 荷包 QQ 交流群（ 643645871 ） 荷包微信交流群微信群可能会有有效期，当不能添加时，大家可以添加我的个人 微信或 QQ（565100605），备注荷包，拉你上车。。目前微信群人较多一些，建议加微信群。。 个人微信添加微信请备注来源 “荷包-个人博客”, 添加微信后，请主动录制个人荷包实时 资产、首页等界面视频以作查验，主要是为了保证每个投资者的真实性。","categories":[{"name":"理财","slug":"manage-money","permalink":"https://leaderliang.coding.me/categories/manage-money/"}],"tags":[{"name":"荷包","slug":"p2p","permalink":"https://leaderliang.coding.me/tags/p2p/"},{"name":"P2P","slug":"p2p","permalink":"https://leaderliang.coding.me/tags/p2p/"}]},{"title":"Android 使用 adb 命令导出想要的手机安装包","slug":"Android-使用-adb-命令导出想要的手机安装包","date":"2019-03-09T05:37:48.000Z","updated":"2019-03-11T15:48:44.183Z","comments":true,"path":"f7d8.html","link":"","permalink":"https://leaderliang.coding.me/f7d8.html","excerpt":"有时候会遇到想快速找到手机的安装包，或者手机里没有这个版本的安装包文件，怎么办呢…","text":"有时候会遇到想快速找到手机的安装包，或者手机里没有这个版本的安装包文件，怎么办呢… adb 取出在手机中安装的apk列出所有安装的apk1adb shell pm list packages 找出自己想要取出 的 apk 包名（com.taobao.taobao）打印 apk 的路径（后面拼上包名）1adb shell pm path com.taobao.taobao package 后面即为路径 导出 apk，pull 后的是要导出的 apk 路径，后面跟上你要导出的路径1adb pull /data/app/com.taobao.taobao-v9lhnghOe8tvxgfkp4AfDQ==/base.apk /Users/liangyanqiao/Downloads/adbpull/taobao.apk 进度 完成 文件夹没有创建，会提示异常，需要自己个创建 导出 Finder","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"}]},{"title":"View 的事件分发机制和触摸反馈机制原理解析","slug":"View-的事件分发和触摸反馈机制原理解析","date":"2019-03-07T15:55:54.000Z","updated":"2020-06-29T10:38:57.376Z","comments":true,"path":"f129.html","link":"","permalink":"https://leaderliang.coding.me/f129.html","excerpt":"在学习和实践中对 View 事件分发的一些简单认识和总结，今天整理一下…","text":"在学习和实践中对 View 事件分发的一些简单认识和总结，今天整理一下…事件分发机制的过程就是一个 MotionEvent 产生以后，系统需要把这个事件传递给具体的view，这个过程就是事件分发过程。 View 的事件分发机制MotionEvent 事件类型 事件类型 MotionEvent 的一个重要概念，就是指 MotionEvent 对象所代表的动作。比如说，当你的一个手指在屏幕上滑动一下时，系统会产生一系列的触摸事件对象,他们所代表的动作有所不同。有的事件代表你手指按下这个动作,有的事件代表你手指在屏幕上滑动,还有的事件代表你手指离开屏幕。这些事件的事件类型就分别为ACTION_DOWN,ACTION_MOVE,和ACTION_UP。上述这些动作所产生的一系列事件，被称为一个事件流，它包括一个ACTION_DOWN 事件，很多个 ACTION_MOVE 事件，和一个 ACTION_UP 事件。 除了前面说的三个事件类型外，还有很多不同的事件类型,比如 ACTION_CANCEL。它代表当前的手势被取消。要理解这个类型，就必须要了解ViewGroup分发事件的机制。一般来说，如果一个子视图接收了父视图分发给它的ACTION_DOWN事件，那么与ACTION_DOWN事件相关的事件流就都要分发给这个子视图，但是如果父视图希望拦截其中的一些事件，不再继续转发事件给这个子视图的话，那么就需要给子视图一个ACTION_CANCEL事件。 常用的事件类型和含义MotionEvent 记录手指接触屏幕以后所产生一系列的事件，也就是事件分发的对象，事件的类型与含义如下： 事件类型 具体动作 MotionEvent.ACTION_DOWN 按下 View （所有事件的开始） MotionEvent.ACTION_MOVE 滑动 View MotionEvent.ACTION_UP 抬起 View （与 DOWN 对应） MotionEvent.ACTION_CANCEL 取消或结束事件 MotionEvent.ACTION_POINTER_DOWN 代表用户又使用一个手指触摸到屏幕上，也就是说，在已经有一个触摸点的情况下，又新出现了一个触摸点 MotionEvent.ACTION_POINTER_UP 代表用户的一个手指离开了触摸屏，但是还有其他手指还在触摸屏上。也就是说，在多个触摸点存在的情况下，其中一个触摸点消失了。它与ACTION_UP的区别就是，它是在多个触摸点中的一个触摸点消失时（此时，还有触摸点存在，也就是说用户还有手指触摸屏幕）产生，而ACTION_UP可以说是最后一个触摸点消失时产生. 事件分发的顺序 (Activity -&gt; Window -&gt; View)事件总是先传递给 Activity，Activity 再传递给 Window，最后 Window 再传递给顶级 View ( DecorView 本质是 ViewGroup，DecorView一般就是当前界面的底层容器(即setContentView所设置的View的父容器)，顶级 View 接收到事件后，就会按照事件分发机制去分发事件。 如果一个View的 onTouchEvent 返回 false，那么它的父容器的 onTouchEvent 将会被调用，依次类推，如果所有的元素都不处理这个事件，那么这个事件最终将会传递给 Activity 处理。 事件分发核心方法 方法名 作用 备注 dispatchTouchEvent(MotionEvent event) 进行事件分发 是第一个被调用的方法，若事件能够传递给当前的 View/ViewGroup，那么这个方法就一定会被调用 onInterceptTouchEvent(MotionEvent event) 进行事件拦截操作（ViewGroup 有此方法，View 没有） 在 dispatchTouchEvent() 方法中调用，如果当前 view 拦截了某一个事件，那么同一个事件序列将不会再调用这个方法 onTouchEvent(MotionEvent event) 进行处理上面提到的事件流 onTouchEvent 是在 dispatchTouchEvent() 方法中被调用的， 事件分发图示（父 View/ ViewGroup 到子 View 的事件分发过程）如下图： 简单来说，view 的 dispatchTouchEvent 自身做的事情并不多，主要是 onTouchEvent()；总结一下就是 父 view 递归的调用 子 view 的 dispatchTouchEvent 的过程。 伪代码演示下他们的调用关系： 12345678910111213141516171819View.dispatchTouchEvent();public boolean dispatchTouchEvent(MotionEvent event) &#123; return onTouchEvent();&#125;ViewGroup.dispatchTouchEvent();public boolean dispatchTouchEvent(MotionEvent event) &#123; boolean result; if (interceptTouchEvent())&#123; result = onTouchEvent(); &#125; else &#123; result = 调用子 view 的 .dispatchTouchEvent(); &#125; return result;&#125; 把 result 结果记录，然后返回（下次在执行时候直接会根据上次记录的 result 进行操作,同一个事件序列将不会再调用） 通过上面的伪代码，可以大致了解点击事件的传递规则：对于一个根 ViewGroup 来说，点击事件产生后，首先会传递给它，这是它的 dispatchTouchEvent 就会被调用，如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 true 就表示它要拦截当前事件，接着事件就会交给这个 ViewGroup 处理，这时如果它的 mOnTouchListener 被设置，则 onTouch 会被调用，否则 onTouchEvent 会被调用。在 onTouchEvent 中，如果 设置了 mOnCLickListener，则 onClick 会被调用。只要 View 的 CLICKABLE 和 LONG_CLICKABLE 有一个为 true，onTouchEvent() 就会返回 true 消耗这个事件。如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 false 就表示它不拦截 当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 dispatchTouchEvent 方法就会被调用，如此反复直到事件被最终处理完。 未完待续…","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"},{"name":"自定义 View","slug":"android/customize-view","permalink":"https://leaderliang.coding.me/categories/android/customize-view/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"}]},{"title":"Linux / Mac 工作常用命令行总结","slug":"Linux-Mac-工作常用命令行总结","date":"2019-03-02T06:47:00.000Z","updated":"2019-03-11T13:45:22.454Z","comments":true,"path":"ffda.html","link":"","permalink":"https://leaderliang.coding.me/ffda.html","excerpt":"mac 常用命令行简单总结，提升开发效率","text":"mac 常用命令行简单总结，提升开发效率 日常文件夹以及文件操作cd 是英文 change directory 的缩写，更改目录的意思(巧用 Tab 键会自动补齐)要进入我们的家目录 1cd ~ 我们要进入下载目录 1cd ~/Downloads/ 需要返回上级目录（在 linux 系统中 . 代表当前目录，..代表上级目录。如果是上级的上级目录，就是 ../..） 1cd .. ls 查看目录下的文件当我们进入到某个文件夹之后，我们不知道里面有什么文件，就可以使用这个命令（ls 是英文 list 的缩写） 1ls 如果我们想要查看更多的内容，就可以在 ls 后加上 -l 参数（执行完就可以看到一个以列表的形式把所有的内容全部输出） 1ls -l 查看隐藏的文件 1ls -a ls -l 也可以和 ls -a 组合在一起使用，可以自己查看下效果哈 1ls -la linux/mac 系统和 windows 系统有一个很大的区别，就是，隐藏文件。在 linux 里，只要一个文件或者文件夹的名字第一个字符是以 . 开头，就表示这是一个隐藏文件。而 windows 系统是右键文件属性来设置的。所以，使用 linux 系统，你如果想要给某个文件夹或者文件隐藏，右击属性是没有这些操作的。只需重命名文件，加个 . 即可对文件设置隐藏。 ls 更多拓展可以查看 Linux命令大全 clear 清空屏幕的内容1clear mv 移动1mv index/text.html html/ 将 index 目录下的 text.html 文件转移到 html 下 cp 复制文件和文件夹mv 命令一样，也是可以跨目录复制的 1cp index/text.html html/ 如果你需要保留文件所有的权限属性之类的，可以加上参数 -a 1cp -a a b 如果你复制的不是文件，而是文件夹，则要加上一个递归的参数 -r 1cp -r a b 复制文件夹，并且要保留所有的权限属性，可以加上参数 -ra 1cp -ra a b 如果你复制的文件夹里面有很多内容，你想看到实时进度的话，可以用 -v 参数 1cp -v a b rm 删除文件或文件夹 注意， rm 命令进行的删除操作，是不会放到系统的回收站里面去的。而是直接删除，如果你希望通过软件把文件找回来的话，也是很困难的。所以，在输入 rm 命令的时候一定谨慎些！ 删除某个具体的文件，而不是命令行里带路径的文件，或者文件夹 1rm file 如果删除的是某个目录，或者带目录的文件，直接用上面的命令是不行的。删除目录必须进行递归操作，所以需要加上参数 -r 。 直接rm就可以了，不过要加两个参数-rf 即：rm -rf 目录名字。若删除时出现 Permission denied 的提示，可以在命令前加sudo 即:sudo rm -rf 文件夹的名字，即可删除。提醒：使用这个rm -rf的时候一定要格外小心，rm 命令执行后是不会到系统回收站的也无法恢复解释：-r 向下递归，不管有多少级目录，一并删除-f 直接强行删除，不作任何提示的意思 123rm -r filePathrm -r filePath/filerm -rf /Users/liangyanqiao/MacDev/Hexo/themes/hexo-theme-skapp touch 新建文件创建一个或者多个文件(创建任意文件,只需要加上不同的后缀就可以啦) 12touch a.txttouch a.txt b.png c.doc mkdir 新建文件夹mkdir 从字面上可以看出是英文 make directory 的缩写 新建一个文件夹或者多个文件夹 1mkdir a b c d 新建多层级的目录，这就需要加上参数 -p，c 后加 / 也可以 12mkdir -p a/b/cmkdir -p a/b/c/ less 查看文本文件1less a.txt pwd 显示当前用户所在的完整路径return working directory name 1➜ Downloads pwd 输出 1/Users/liang/Downloads man 查看某个命令的详情1man pwd Mac终端 vi/vim 的简单使用基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），插入模式（Insert mode）和底线命令模式（Last line mode） 命令模式：用户刚刚启动 vi/vim，便进入了命令模式。 i 切换到插入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式输入模式：在命令模式下按下 i 就进入了输入模式。 在输入模式中，可以使用以下按键： ENTER(回车键) 换行 BACK SPACE(退格键) 删除光标前一个字符 方向键 在文本中移动光标 HOME/END 移动光标到行首/行尾 Page Up/Page Down 上/下翻页 ESC 退出输入模式，切换到命令模式底线命令模式：1234567891011在命令模式下按下 :（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。在底线命令模式中，基本的命令有（已经省略了冒号）：q 退出程序w 保存文件按 ESC 键可随时退出底线命令模式。 vi/vim 使用实例使用 vi 来建立名为 test.txt 的文件 1vi test.txt 按下 ESC 按钮回到一般模式 在一般模式中按下 :wq 储存后离开 vi vi/vim 按键说明(一般模式下)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273h 或 向左箭头键(←) 光标向左移动一个字符j 或 向下箭头键(↓) 光标向下移动一个字符k 或 向上箭头键(↑) 光标向上移动一个字符l 或 向右箭头键(→) 光标向右移动一个字符如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 &quot;30j&quot; 或 &quot;30↓&quot; 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ Ctrl + f 屏幕『向下』移动一页，相当于 [Page Down]按键Ctrl + b 屏幕『向上』移动一页，相当于 [Page Up] 按键 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处$ 或功能键[End] 移动到这一行的最后面字符处G 移动到这个档案的最后一行gg 移动到这个档案的第一行n&lt;Enter&gt; n 为数字。光标向下移动 n 行 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可n 重复前一个搜寻的动作N 『反向』进行前一个搜寻动作:n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2:n1,$s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2:n1,$s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代 x 向后删除一个字符X 向前删除一个字符 dd 删除游标所在的那一整行ndd n 为数字。删除光标所在的向下 n 行(包括游标所在的那一行) yy 复制游标所在的那一行nyy n 为数字。复制光标所在的向下 n 行 p 为将已复制的数据在光标下一行贴上P 为将已复制的数据在光标上一行贴上 u 复原前一个动作(撤销)Ctrl + r 重做上一个动作. 重复前一个动作 一般模式切换到编辑模式123456789101112131415161718192021i 从目前光标所在处插入I 在目前所在行的第一个非空格符处开始插入 a 从目前光标所在的下一个字符处开始插入A 从光标所在行的最后一个字符处开始插入 o 在目前光标所在的下一行处插入新的一行O 在目前光标所在处的上一行插入新的一行 r 只会取代光标所在的那一个字符一次R 会一直取代光标所在的文字，直到按下 ESC 为止 一般模式切换到指令行模式123456789101112131415:w 将编辑的数据写入硬盘档案中:w! 强制将编辑的数据写入硬盘档案中:q 离开:q! 为强制离开不储存档案:wq 储存后离开:wq! 强制储存后离开:set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号:set nonu 取消行号","categories":[],"tags":[{"name":"mac","slug":"mac","permalink":"https://leaderliang.coding.me/tags/mac/"},{"name":"linux","slug":"linux","permalink":"https://leaderliang.coding.me/tags/linux/"}]},{"title":"Bitmap 和 Drawable 相关整理","slug":"Bitmap-和-Drawable-相关整理","date":"2019-02-27T06:23:37.000Z","updated":"2019-03-26T11:01:03.238Z","comments":true,"path":"d7ac.html","link":"","permalink":"https://leaderliang.coding.me/d7ac.html","excerpt":"Bitmap 和 Drawable 本质区别是什么，来一起简单了解下它的本质吧…","text":"Bitmap 和 Drawable 本质区别是什么，来一起简单了解下它的本质吧… Bitmap 和 Drawable 本质区别Bitmap 是什么？字面理解是位图，位图就是一个图像的完整数据 123456image:width:640;height:640;0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff 在内存里以位图形式存储一个图片的所有像素信息，可以用上面的形式来表示。 Drawable 是什么？Drawable 更像是一个抽象版的自定义的 view，但 Drawable 只负责绘制，只是一个绘制工具。Drawable 不是一个被绘制的对象（path、circle、line 等等都是被 canvas 绘制的对象），更像是一个 view，它持有 canvas，只负责绘制，它想怎么绘制就按照自己规则去绘制。Drawable 内部存储的是一个绘制规则，这个规则可以是一个具体的一个具体的 bitmap、颜色、抽象的灵活的描述，Drawable 是不能含有具体的像素信息。 用代码简单举个例子 123456789101112131415161718public class DrawableView extends View &#123; Drawable drawable; public DrawableView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; &#123; drawable = new ColorDrawable(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); drawable.setBounds(100, 100, getWidth(), getHeight()); drawable.draw(canvas); &#125;&#125; 自定义 Drawable1234567891011121314151617181920public class DrawableView extends View &#123; Drawable drawable; public DrawableView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; &#123; drawable = new MeshDrawable(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas);// drawable.setBounds(100, 100, getWidth(), getHeight()); drawable.setBounds(0, 0, getWidth(), getHeight()); drawable.draw(canvas); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MeshDrawable extends Drawable &#123; private static final int INTERVAL = (int) Utils.dpToPixel(80); Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); &#123; paint.setColor(Color.RED); paint.setStrokeWidth(Utils.dpToPixel(2)); &#125; @Override public void draw(@NonNull Canvas canvas) &#123; for (int i = 0; i &lt; getBounds().right; i += INTERVAL) &#123; System.out.println(&quot;外 i = &quot; + i ); for (int j = 0; j &lt; getBounds().bottom; j += INTERVAL) &#123; System.out.println(&quot;内 i = &quot; + i + &quot; j = &quot; + j); // 画 横线 canvas.drawLine(getBounds().left, j, getBounds().right, j, paint); // 画 竖线 canvas.drawLine(i, getBounds().top, i, getBounds().bottom, paint); &#125; &#125; &#125; @Override public void setAlpha(int alpha) &#123; paint.setAlpha(alpha); &#125; @Override public int getAlpha() &#123; return paint.getAlpha(); &#125; @Override public void setColorFilter(@Nullable ColorFilter colorFilter) &#123; paint.setColorFilter(colorFilter); &#125; @Override public int getOpacity() &#123; return paint.getAlpha() == 0 ? PixelFormat.TRANSPARENT : paint.getAlpha() == 0xff ? PixelFormat.OPAQUE : PixelFormat.TRANSLUCENT; &#125;&#125; Bitmap 和 Drawable 之间互相转换12// bitmap --&gt; DrawableDrawable drawble = new BitmapDrawable(getResources(),bitmap); 这两个类本身就不是一个概念，就不存在相互转换的操作，如果真有这样的需求，也是可以实现效果。 如果非要 Drawable –&gt; bitmap 转换，就只能硬画了。 123456789101112131415161718192021222324252627// Drawable --&gt; bitmap/* 调用*/Bitmap icon = BitmapFactory.decodeResource(context.getResources(),R.drawable.icon_resource);public static Bitmap drawableToBitmap (Drawable drawable) &#123; Bitmap bitmap = null; if (drawable instanceof BitmapDrawable) &#123; BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable; if(bitmapDrawable.getBitmap() != null) &#123; return bitmapDrawable.getBitmap(); &#125; &#125; if(drawable.getIntrinsicWidth() &lt;= 0 || drawable.getIntrinsicHeight() &lt;= 0) &#123; bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888); // Single color bitmap will be created of 1x1 pixel &#125; else &#123; bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight()); drawable.draw(canvas); return bitmap;&#125;","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"},{"name":"Java","slug":"android/java","permalink":"https://leaderliang.coding.me/categories/android/java/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://leaderliang.coding.me/tags/java/"},{"name":"HTTP","slug":"HTTP","permalink":"https://leaderliang.coding.me/tags/HTTP/"}]},{"title":"加密、编码、Hash、序列化和字符集","slug":"加密、编码、Hash、序列化和字符集","date":"2019-02-13T04:16:48.000Z","updated":"2019-03-11T15:44:20.456Z","comments":true,"path":"d80f.html","link":"","permalink":"https://leaderliang.coding.me/d80f.html","excerpt":"最近在学习 HenCoder Plus 的二期课程，想巩固一下基础的同时，也在这里记录一下","text":"最近在学习 HenCoder Plus 的二期课程，想巩固一下基础的同时，也在这里记录一下，结合讲义做一下笔记。记录加密、编码、Hash、Base64、压缩与解压缩、序列化和字符集 密码学古典密码学起源于古代战争：在战争中，为了防止书信被截获后重要信息泄漏，人们开始对书信进行加密。 移位式加密如密码棒，使用布条缠绕在木棒上的方式来对书信进行加密。 替换式加密按照一定规则使用不同的文字来替换掉原先的文字来进行加密。 现代密码学 可以加密任何二进制数据 非对称加密的出现使得密码学有了更广泛的用途：数字签名 对称加密原理：通信双方使用同一个密钥，使用加密算法配合上密钥来进行加密，解密时使用加密过程的完全逆过程配合密钥来进行解密。使用密钥和加密算法对数据进⾏转换，得到的无意义数据即为密文;使⽤密钥和解密算法对密文进行逆向转换，得到原数据 对称加密的经典算法DES（56位密钥，密钥太短而逐渐被弃用）、AES（128位、192位、256位密钥，现在最流行） 对称加密作用加密通信，防止信息在不安全网络上被截获后，信息被人读取或篡改 对称加密缺点不能在不安全网络上传输密钥，一旦密钥泄露则加密通信失败。 非对称加密原理：使用公钥对数据进行加密得到密文；使用私钥对数据进行解密得到原数据。 使⽤非对称加密通信，可以在不可信网络上将双方的公钥传给对⽅，然后在发消息前分别对消息使用对方的公钥来加密和使⽤⾃己的私钥来签名，做到不可信网络上的可靠密钥传播及加密通信。 由于私钥和公钥相互可解，因此非对称加密还可以用于数字签名技术。 经典算法：RSA（可用于加密和签名）、DSA（仅用于签名，但速度更快）优缺点： 有点：可以在不安全网络上传输密钥 缺点：计算复杂，因此性能相比对称加密差很多 密钥和登录密码密钥 key 场景：用于加密和解密 目的：办证数据被盗时不会被人读懂内容 焦点：数据 登录密码 password 场景：用户进入网站或游戏前的身份认证 目的：数据提供方或应用服务方对账户拥有者数据的保护，保证 only you 才提供权限 焦点：身份 编码Base64概念：将二进制数据转换成由 64 个字符组成的字符串的编码算法 二进制数据？ 广义：所有计算机数据都是二进制数据 狭义：非文本数据 即 为二进制数据 Base64 索引表 Base64 用途 将二进制数据扩充了储存和传输途径(例如可以把数据保存到文本⽂件、可以通过聊天对话框或短信形式发送二进制数据、可以在 URL 中加入简单的二进制数据) 普通的字符串在经过 Base64 编码后的结果会变得肉眼不可读，因此可以适⽤于一定条件下的防 偷窥(较少⽤) Base64 缺点因为自身的原理(6 位变 8 位)，因此每次 Base64 编码之后，数据都会增⼤约 1/3，所以会影响存储和传输性能。 Base64 加密图片传输安全高效？不安全不高效！首先，自身并不是加密，另外 Base64 会导致数据增大，降低网络性能，增大用户流量开销。Base64 对图片进行编码的用处在于，有时需要使用文本形式来传输图片。除此之外，没有必要使用它对图片进行额外处理。 压缩与解压缩含义 压缩：将数据使用更具有存储优势的编码算法进行编码。 解压缩：将压缩数据解码还原成原来的形式，以方便使用。 目的减小数据占用的存储空间 压缩是编码吗？是编码，编码，是指把数据从一种形式转换为另外一种形式。压缩过程属于编码过程，解压缩过程属于解码过程。 常见压缩算法DEFLATE、JPEG、MP3 序列化把数据对象（一般是内存中的，例如 JVM 中的对象）转换成字节序列的过程。对象在程序内存里的存放形式是散乱的（存放在不同的内存区域、并且由引用进行连接），通过序列化可以把内存中的对象转换成一个字节序列，从而使用 byte[] 等形式进行本地存储或网络传输，在需要的时候重新组装（反序列化）来使用。 目的让内存中的对象可以被存储和传输 序列化是编码吗？不是 序列化和编码的区别？编码是把数据由一种数据格式转换成另一种数据格式；而序列化是把数据由内存中的对象（而不是某种具体的格式）转换成字节序列。 Hash把任意数据转换成指定大小范围（通常很小，例如 256 字节以内）的数据。 作用相当于从数据中提出摘要信息，因此最主要用途是数字指纹。 实际用途：唯一性验证。例如 java 中 hashCode（）方法。 怎么重写 hashCode 方法？把 equals（） 方法中的每个用于判断相等的变量都放进 hashCode（） 中，一起生成一个尽量不会碰撞的整数即可。 实际用途 数据完整性验证。从⽹络上下载⽂件后，通过⽐对文件的 Hash 值(例如 MD5、SHA1)，可以确认下载的⽂件是否有 损坏。如果下载的⽂件 Hash 值和⽂文件提供⽅给出的 Hash 值⼀致，则证明下载的⽂文件是完好⽆损 的。 隐私保护（不属于加密）。当重要数据必须暴露的时候，有事可以选择暴露它的 Hash 值(例如 MD5)，以保障原数据的安全。 例如网站登录时，可以只保存用户密码的 Hash 值，在每次登录验证时只需要将输⼊的密码的 Hash 值和数据库中保存的 Hash 值作⽐对就好，⽹站无需知道⽤户的密码。这样，当⽹站数据失窃时，用户不会因为⾃己的密码被盗导致其他⽹站的安全也受到威胁。 快速查找。 HashMap hash 是编码吗？不是。hash 是单向过程，是不可逆的，无法进行逆向恢复操作，因此 hash 不属于编码。 hash 是加密吗？不是。 hash 是单向过程，无法进行逆向恢复操作，因此 hash 不属于加密。（MD5 不是加密！） 字符集一个由整数向现实世界中的文字符号的 map 分支 ASCII:128 个字符，1 字节 ISO-8859-1:对 ASCII 进⾏行行扩充，1 字节 Unicode:13 万个字符，多字节 UTF-8:Unicode 的编码分⽀支UTF-16 :Unicode 的编码分⽀支 GBK / GB2312 / GB18030:中国⾃自研标准，多字节，字符集 + 编码","categories":[{"name":"Java","slug":"java","permalink":"https://leaderliang.coding.me/categories/java/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://leaderliang.coding.me/tags/java/"}]},{"title":"HTTP 的原理和工作机制学习笔记整理","slug":"HTTP-的原理和工作机制学习笔记整理","date":"2019-01-30T14:27:58.000Z","updated":"2019-03-11T15:46:03.022Z","comments":true,"path":"50ea.html","link":"","permalink":"https://leaderliang.coding.me/50ea.html","excerpt":"","text":"最近在学习 HenCoder Plus 的二期课程，想巩固一下基础的同时，也在这里记录一下，结合讲义做一下笔记。 HTTP 的定义（Hypertext Transfer Protocol）一种网络协议传输协议，位于 TCP/IP 协议族的最顶层–（应用层）；超文本传输协议，和 HTML（Hypertext Markup Language） 超文本标记一起诞生，用于在网络上请求和传输 HTML 内容。超⽂文本，即「扩展型⽂文本」，指的是 HTML 中可以有链向别的⽂文本的链接(hyperlink)。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Page Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;This is a Heading&lt;/h1&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTTP 的工作方式浏览器：用户输入地址后回车或点击链接 -&gt; 浏览器拼装 HTTP 报⽂并发送请求给服务器 -&gt; 服务器处理理请求后 发送响应报文给浏览器 -&gt; 浏览器解析响应报⽂并使⽤渲染引擎显示到界⾯ 手机 App： ⽤户点击或界⾯自动触发联网需求 -&gt; Android 代码调⽤拼装 HTTP 报⽂并发送请求到服务器器 -&gt; 服务器处理理请求后发送响应报文给手机 -&gt; Android 代码处理响应报文并作出相应处理理(如储存数据、加⼯数据、显示数据到界面) URL 和 HTTP 报文URL 格式三部分：协议类型、服务器地址（和端口号）、路径（path）协议类型： //服务器地址[:端口号]路径 报文格式请求报文请求行： 1GET(method) + /users （path）+ HTTP/1.1 (HTTP version) Headers： 123Host：api.github.com Content-Type: text/plain Content-Length: 243 Body: 1balabalabala.... 响应报文结构状态行： 1HTTP/1.1(HTTP version) + 200(state code) + OK (state msg) Headers： 12345content-type: application/json; charset=utf-8cache-control: public, max-age=60, s-maxage=60vary: Accept,Accept-Encodingetag: W/&quot;02eec5b334b0e4c05253d3f4138daa46&quot;content-encoding: gzip Body: 123[&#123;&quot;login&quot;:&quot;mojombo&quot;,&quot;id&quot;:1,&quot;node_id&quot;:&quot;MDQ6VXNlcjE=&quot;,&quot;avatar_url&quot;:&quot;https://avatars0.githubusercontent.com/u/1?v=4&quot;,&quot;gravat...... Request Method 请求方法GET 特点 用户获取资源 对服务器数据不进行修改 不发送 Body POST 特点 用于增加或修改资源 发送给服务器的内容写在 Body 里面 12345POST /users HTTP/1.1Host: api.github.comContent-Type: application/x-www-form-urlencodedContent-Length: 13name=rengwuxian&amp;gender=male PUT 特点 用于修改资源 发送给服务器的内容写在 Body 里面 DELETE 特点 用于删除资源 不发送 Body HEAD 特点 和 GET 使用方法完全相同 和 GET 唯一区别在于，返回的响应中没有 Body State Code 状态码三位数字，⽤于对响应结果做出类型化描述(如 获取成功、内容未找到） 1xx:临时性消息。如:100 (继续发送)、101(正在切换协议) 2xx:成功。最典型的是 200(OK)、201(创建成功) 3xx:重定向。如 301(永久移动)、302(暂时移动)、304(内容未改变) 4xx:客户端错误。如 400(客户端请求错误)、401(认证失败)、403(被禁⽌止)、404(找 不不到内容) 5xx:服务器器错误。如 500(服务器器内部错误)。 Cache 和 Buffer 的区别Cache 是缓存，为了提升效率速度。Buffer 是缓冲，上游多生产一些，给下游使用。","categories":[{"name":"理论基础","slug":"theory","permalink":"https://leaderliang.coding.me/categories/theory/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://leaderliang.coding.me/tags/HTTP/"}]},{"title":"聊聊 Java 的面向对象以及接口和抽象类的区别?","slug":"聊聊-Java-接口和抽象类的区别","date":"2019-01-20T17:59:58.000Z","updated":"2019-03-26T11:01:15.533Z","comments":true,"path":"92d0.html","link":"","permalink":"https://leaderliang.coding.me/92d0.html","excerpt":"Java 是非常典型的面向对象语言，掌握面向对象设计原则和技巧，是保证高质量代码的基础之一。面向对象提供的基本机制，对于提高开发、沟通等各方面效率也至关重要。","text":"Java 是非常典型的面向对象语言，掌握面向对象设计原则和技巧，是保证高质量代码的基础之一。面向对象提供的基本机制，对于提高开发、沟通等各方面效率也至关重要。最近通过在极客时间里学习杨晓峰老师的课程，再回顾一下 java 方面的一些基础知识，在这里简单记录一下。 面向对象谈到面向对象，我们一定要清楚面向对象的基本要素：封装、继承、多态。 面向对象的基本要素封装目的是隐藏事务内部的实现细节，以便提高安全性和简化编程。封装提供了合理的边界，避免外部调用者接触到内部的细节。我们在日常开发中，因为无意间暴露了细节导致的难缠 bug 太多了，比如在多线程环境暴露内部状态，导致的并发修改问题。从另外一个角度看，封装这种隐藏，也提供了简化的界面，避免太多无意义的细节浪费调用者的精力。 继承是代码复用的基础机制.但要注意，继承可以看作是非常紧耦合的一种关系，父类代码修改，子类行为也会变动。在实践中，过度滥用继承，可能会起到反效果。 多态说到多态，可能立即会想到重写（override）和重载（overload）、向上转型。重写是父子类中相同名字和参数的方法，不同的实现；重载则是相同名字的方法，但是不同的参数，本质上这些方法签名是不一样的，为了更好说明，请参考下面的样例代码： 12345678910111213public int doSomething() &#123; return 0;&#125;/*输入参数不同，意味着方法签名不同，重载的体现*/ public int doSomething(List&lt;String&gt; strs) &#123; return 0;&#125;/*return 类型不一样，编译不能通过;方法名称和参数一致，但是返回值不同，这种情况在 Java 代码中不算有效的重载*/ public short doSomething(List&lt;String&gt; strs) &#123; return 0;&#125; 面向对象设计原则（S.O.L.I.D）英文简称 | 英文描述 | 中文名称—|—OCP | Open Closed Principle | 开放封闭原则SRP | Single Responsibility Principle | 单一职责原则LSP | Liskov Substitution Principle | 里氏替换原则ISP | Interface Segregation Principle | 接口分离原则DIP | Dependency Inversion Principle | 依赖倒置原则 下面通俗解释参考来源：CSDN xiong_it，感谢~ 开关原则（开闭原则）（Open-Close, Open for extension, close for modification Principle） 开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层次模块的变化，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。在业务规则改变的情况下高层模块必须有部分改变以适应新业务，改变要尽量地少，防止变化风险的扩散。—秦小波《设计模式之禅》 设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。 通俗解释：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。OCP 是 6 大原则的最高纲领，所以才如此抽象，晦涩难懂。用面向对象的语言来讲，OCP（开闭原则） 是一个最抽象的接口，而其余的5大原则只是OCP的子类接口，他们一起定义了 OOP 世界的开发标准，常用的 23 种设计模式更是只能算作这 6 大原则的实现抽象类，咱们开发的代码实践才是真正的具体子类。 单一职责原则（Single Responsibility Principle）类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。 通俗解释：应该有且只有一个原因引起类的变更。（一个类，一个方法只应该做一件事情） 这种方式是如何体现扩展性的呢？拿一个Android中最常见的ImageLoader的设计来举例子，ImageLoader主要需要实现2个功能，下载图片，缓存图片。假如，我们把所有的功能全部放在一个ImageLoader类中，假设下载要改方式呢？缓存要改策略呢？你通通要改ImageLoader，你如何保证修改某个功能的过程中另一个功能依旧完好，没被污染？拆分职责，使用ImageCache接口及其子类实现进行缓存，和ImageLoader建立关联，职责单一了，你再在每个单一的职责类里面去修改相关代码，这样其他功能代码被污染的概率大大降低。当然，这里只是随意举的例子，划分单一职责这个度很难把握，每个人都需要根据自身情况和项目情况来进行判断。 里氏替换原则（Liskov Substitution Principle）这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。 通俗解释：只要父类能出现的地方子类就可以出现，而且替换为子类也不产生任何异常错误，反之则不然。这主要体现在，我们经常使用抽象类/基类做为方法参数，具体使用哪个子类作为参数传入进去，由调用者决定。 这条原则包含以下几个方面： 子类必须完全实现父类的方法； 子类可以有自己的个性外观（属性）和行为（方法）； 覆盖或者实现父类方法时，参数可以被放大，即父类的某个方法参数为HashMap时，子类参数可以是HashMap，也可以是Map或者更大； 覆盖或者实现父类的方法时，返回结果可以被缩小，即父类的某个方法返回类型是Map，子类可以是Map，也可以是HashMap或者更小。 接口分离原则（Interface Segregation Principle）我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响。 通俗解释：客户端不应该依赖它不需要的接口，类间的依赖应该建立在最小的接口上；使用接口时应该建立单一接口，不要建立臃肿庞大的接口，尽量给调用者提供专门的接口，而非多功能接口。这里我想举个 Android 中的事件处理 Listener 设计的例子，大家都知道，我们想给 button 添加点击或长按事件时，可以使用如下代码 12button.setOnClickListener(clickListener); button.setOnLongClickListener(longClickListener); 还有其他比如 OnTouchListener 等等等事件接口，它为什么不直接提供一个通用的接口 IListener 呢？然后回调所有的事件给调用者处理，而要提供这么多独立的接口，这就是遵循了 ISP 原则的结果，每个接口最小化了，Activity/button 作为调用者，我可以选择性的去处理我想处理的事件，不关心的事件 Listener 我就不去处理和依赖。 依赖反转原则或依赖倒置原则（Dependency Inversion Principle）实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝。 通俗解释：抽象：Java中体现为基类，抽象类，接口，而不单指抽象类细节：体现为子类，实现类 通俗点讲，该原则包含以下几点要素： 模块间的依赖应该通过抽象发生，具体实现类之间不应该建立依赖关系 接口或者抽象类不依赖于实现类，否则就失去了抽象的意义 实现类依赖于接口或者抽象类 总结起来，一句话：”面向接口编程“。 以上为最通用的部分，另外还有一个原则： 迪米特法则（Demeter Principle）：又称最少知识原则（Least Knowledge Principle， LKP）一个对象应该对其他对象有最少的了解。通俗点讲：一个类应该对自己需要耦合或者调用的类知道越少越好，被耦合或者调用的类内部和我没有关系，我不需要的东西你就别 public 了。迪米特法则包含以下几点要素：只和朋友类交流：只耦合该耦合的类朋友间也是有距离的：减少不该public的方法，向外提供一个简洁的访问自家的方法就自己创建：只要该方法不会增加内部的负担，也不会增加类间耦合 OOP 原则在面试题目中的分析 OOP 的全称是 Object Oriented Programming，即面向对象编程,它的设计原则对于指导开发有实际意义。S.O.L.I.D 是面向对象设计(OOD)和面向对象编程(OOP)中的几个重要编码原则(Programming Priciple)的首字母缩写。 借用极客时间里的代码 12345678910public class VIPCenter &#123; void serviceVIP(T extend User user) &#123; if (user instanceof SlumDogVIP) &#123; // 穷 X VIP，活动抢的那种 // do somthing &#125; else if(user instanceof RealVIP) &#123; // do somthing &#125; ... &#125; 这段代码的一个问题是，业务逻辑集中在一起，当出现新的用户类型时，比如，大数据发现了我们是肥羊，需要去收获一下， 这就需要直接去修改服务方法代码实现，这可能会意外影响不相关的某个用户类型逻辑。 利用开关原则，尝试改造为下面的代码： 12345678910111213141516171819202122public class VIPCenter &#123; private Map&lt;User.TYPE, ServiceProvider&gt; mProviders; void serviceVIP(T extend User user） &#123; mProviders.get(user.getType()).service(user); &#125; &#125; interface ServiceProvider&#123; void service(T extend User user) ; &#125; class SlumDogVIPServiceProvider implements ServiceProvider&#123; void service(T extend User user)&#123; // do somthing &#125; &#125; class RealVIPServiceProvider implements ServiceProvider&#123; void service(T extend User user) &#123; // do something &#125; &#125; 上面的示例，将不同对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码的隔离保证了方便的扩展。 如何回答接口和抽象类两者的区别？接口和抽象类是 Java 面向对象设计的两个基础机制。 接口接口，不能实例化；Java 类实现 interface 使用 implements 关键词;接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的;不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。Java 标准类库中，定义了非常多的接口，比如 java.util.List，可以查看 list 的源码来了解。 抽象类抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。Java 标准库中，比如 collection 框架，很多通用部分就被抽取成为抽象类，例如 java.util.AbstractList。继承 abstract class 则是使用 extends 关键词，我们可以参考 Java 标准库中的 ArrayList。 1234public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ...&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://leaderliang.coding.me/categories/java/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://leaderliang.coding.me/tags/java/"}]},{"title":"Java 基础面试问题整理","slug":"Java-基础面试问题整理","date":"2018-06-26T10:36:52.000Z","updated":"2019-11-23T05:29:52.265Z","comments":true,"path":"d44b.html","link":"","permalink":"https://leaderliang.coding.me/d44b.html","excerpt":"对 java 的重要的一些基础知识点进行一个简单的总结，方便对碎片知识进行回顾。","text":"对 java 的重要的一些基础知识点进行一个简单的总结，方便对碎片知识进行回顾。持续更新… Thread怎么安全停止一个线程任务？原理是什么？thread.stop（）；不可用，危险 替换为thread.interrupt（）；interrupt 是一种温和的打断 的线程终结。 Thread.interrupted();会检查自己当前的线程，正在运行的线程的运行状态，并且重置线程的状态。true 变为 false，false 的话，就不处理。isInterrupted(); 只是检查自己，自己的状态。安卓自己有个 sleep 的方法 SystemClock.sleep(2000); 不用处理异常。 Java 基础面试问题整理GC 回收，原理？xxx String 相关问题整理如何比较两个字符串？使用“==”还是equals()方法？“==” 测试的是两个对象的引用是否相同；equals()比较的是两个字符串的值是否相等。除非你想检查的是两个字符串是否是同一个对象，否则你应该使用equals()来比较字符串。 .equals() 和 == 区别？ 首先的区别是，equals() 是方法，而 == 是操作符； 对于基本类型的变量来说（如 short、 int、 long、 float、 double），只能使用 == ，因为这些基本类型的变量没有 equals 方法。对于基本类型变量的比较，使用 == 比较， 一般比较的是它们的值。 对于引用类型的变量来说（例如 String 类）才有 equals 方法，因为 String 继承了 Object 类， equals 是 Object 类的通用方法。对于该类型对象的比较，默认情况下，也就是没有复写 Object 类的 equals 方法，使用 == 和 equals 比较是一样效果的，都是比较的是它们在内存中的存放地址。 对于 equals 方法被重写的情况, 以 String 类为例, String 类复写了 equals 方法，当使用 == 比较内存的存放地址不相等时，接下来会比较字符串的内容是否 相等，所以 String 类中的 equals 方法会比较两者的字符串内容是否一样。内容的比较。 String、StringBuffer、StringBuilderString字符串常量，用于存放字符的数组被声明为final，因此只能赋值一次，不可再更改。频繁使用 String 来操作字符串实际上是在不断地创建新的对象，这样会对系统的性能产生影响，适用于操作少量数据。StringBuffer 字符串变量，适合于多线程操作下操作大量数据，线程安全的可变字符序列StringBuilder 字符串变量，适合于单线程下操作大量数据，线程不安全的可变字符序列String 对象的字符串拼接在编译时会转化成 StringBuilder 的 append 操作运行速率 String &lt; StringBuffer &lt; StringBuilder String s = new String(“111”) 创造了几个对象？ 会创造两个对象。Java为了避免产生大量的String对象，设计了一个字符串常量池。JDK6之前版本，常量池的内存在永久代进行分配，JDK7之后常量池的内存在Java堆中进行分配。创建一个字符串时，JVM首先检查字符串常量池中是否有相等的字符串，如果有则不再创建并返回该字符串的引用地址；如果没有则在字符串常量中创建字符串并返回该字符串的引用地址。new 一个 String 对象时还会在堆内存中创建一个新的对象。 String为啥设计成不可变的？ 用于存放字符的数组被声明为final，因此只能赋值一次，不可再更改，而且String 也没有对外暴露修改数组的方法。修改String时，不会在原有的内存地址修改，而是重新指向一个新对象。不可变性可以保证线程安全以及字符串串常量池的实现。 可以重新赋值么？可以通过反射的Field方法获取到当前对象的成员变量并重新赋值； String 相关待整理… Java的强、软、弱、虚四种引用的区别?强引用：代码中普遍存在的，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象。软引用：SoftReference，用来描述还有用但是非必须的对象，当内存不足的时候回收这类对象。弱引用：WeakReference，用来描述非必须对象，弱引用的对象只能生存到下一次 GC 发生时，当 GC 发生时，无论内存是否足够，都会回收该对象。虚引用：PhantomReference，一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，可通过判断引用队列是否加入虚引用来回收对象。 final 和 finally 和 finalize 的区别？final修饰符(关键字)类被声明为final，它不能派生出新的子类，不能作为父类被继承；方法被声明为final，只能使用，不能重写；变量声明为final，在使用过程中不会改变，只能读取不可修改。 finally(用于异常处理)一般用于异常处理中，finally是对异常处理的补充，finally结构使代码总会执行，不管有无异常发生。使用finally可以维护对象的内部状态，并可以清理资源 finalize(用于垃圾回收)Object中定义的方法，使用finalize()方法在垃圾收集器将对象从内存中回收之前做必要的清理工作 Java 静态代理和动态代理为某个对象提供一个代理，以控制对这个对象的访问静态代理：程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就已经确定动态代理：程序运行期时由 JVM 动态的生成，代理类和委托类的关系是在运行时确定。使用场景：如果需要对多个类进行代理，并且代理的功能都是一样的，用静态代理重复编写代理类就非常的麻烦，可以用动态代理动态的生成代理类。RxJava 里就有使用动态代理。 Java 内存中堆和栈的区别 参考：https://www.jianshu.com/p/947a76e2ddbc 堆内存 是用于存储 Java 中的对象和数组，当我们 new 一个对象或者创建一个数组的时候，就会在堆内存中开辟一段空间给他，用于存放。堆内存的特点是先进先出，后进后出，堆是在运行时动态的分配内存大小，缺点是存取速度较慢。 堆内存用于存放由new创建的对象和数组。在堆内存中分配的内存空间，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，变量的值就等于数组或对象在堆内存中的首地址，而这个栈中的特殊变量，也就成为数组或对象的引用变量。以后可以在程序中使用栈内存中的引用变量访问堆内存中的数组或对象了。引用变量相当于是为数组或对象起的一个别名，或者是代号。数组和对象在没有引用变量指向它的时候，才变成垃圾，不能被继续使用，但是仍然会占用堆内存空间，而后在一个不确定的时间内，由java虚拟机自动垃圾回收器回收，这也是java程序为什么会占用很大内存的原因。 栈内存 是用来执行程序用的，存放基本类型的变量和对象的引用变量.栈内存的特点是先进后出，后进先出，栈内存存取速度比堆要快，栈数据可以共享，缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。 在函数中定义的基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中声明了一个变量时，java就会在栈内存中为这个变量分配内存空间，当超过变量的作用域之后，java也会自动释放为该变量分配的空间，而这个回收的空间可以即刻用作他用。 遍历 Map 对象的四种方式？既然java中的所有map都实现了Map接口，以下方法适用于任何map实现（HashMap, TreeMap, LinkedHashMap, Hashtable, 等等） 在for-each循环中使用entries来遍历这是最常见的并且在大多数情况下也是最可取的遍历方式。在键值都需要时使用。 12345Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue());&#125; 注意：for-each循环在java 5中被引入所以该方法只能应用于java 5或更高的版本中。如果你遍历的是一个空的map对象，for-each循环将抛出NullPointerException，因此在遍历前你总是应该检查空引用。 在for-each循环中遍历keys或values如果只需要 map 中的键或者值，你可以通过 keySet 或 values 来实现遍历，而不是用 entrySet。 该方法比entrySet遍历在性能上稍好（快了10%），而且代码更加干净 1234567891011Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //遍历map中的键for (Integer key : map.keySet()) &#123; System.out.println(&quot;Key = &quot; + key); &#125; //遍历map中的值for (Integer value : map.values()) &#123; System.out.println(&quot;Value = &quot; + value); &#125; 使用Iterator遍历使用泛型： 123456Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator(); while (entries.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = entries.next(); System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue()); &#125; 不使用泛型： 12345678Map map = new HashMap();Iterator entries = map.entrySet().iterator(); while (entries.hasNext()) &#123; Map.Entry entry = (Map.Entry) entries.next(); Integer key = (Integer)entry.getKey(); Integer value = (Integer)entry.getValue(); System.out.println(&quot;Key = &quot; + key + &quot;, Value = &quot; + value);&#125; 你也可以在keySet和values上应用同样的方法。 该种方式看起来冗余却有其优点所在。首先，在老版本java中这是惟一遍历map的方式。另一个好处是，你可以在遍历时调用iterator.remove()来删除entries，另两个方法则不能。根据javadoc的说明，如果在for-each遍历中尝试使用此方法，结果是不可预测的。 从性能方面看，该方法类同于 for-each 遍历（即方法二）的性能。 通过键找值遍历（效率低）12345Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();for (Integer key : map.keySet()) &#123; Integer value = map.get(key); System.out.println(&quot;Key = &quot; + key + &quot;, Value = &quot; + value);&#125; 作为方法一的替代，这个代码看上去更加干净；但实际上它相当慢且无效率。因为从键取值是耗时的操作（与方法一相比，在不同的Map实现中该方法慢了20%~200%）。如果你安装了FindBugs，它会做出检查并警告你关于哪些是低效率的遍历。所以尽量避免使用。 总结如果仅需要键(keys)或值(values)使用方法二。如果你使用的语言版本低于java 5，或是打算在遍历时删除entries，必须使用方法三。否则使用方法一(键值都要)。 list 与 Set、Map区别及适用场景List,Set都是继承自 Collection 接口，Map则不是 List特点：元素有放入顺序，元素可重复；list支持for循环，也就是通过下标来遍历，也可以用迭代器；Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的 Object必须定义equals()方法 ，set 只能用迭代，因为他无序，无法用下标来取得想要的值。） Set 和 List 对比： Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。 List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。 Map 适合储存键值对的数据 线程安全集合类与非线程安全集合类LinkedList、ArrayList、HashSet 是非线程安全的，Vector 是线程安全的;HashMap 是非线程安全的，HashTable 是线程安全的;StringBuilder 是非线程安全的，StringBuffer 是线程安全的。 HashSet 和 HashMap 怎么判断集合元素重复？需要重写 hashcode 方法与 equals 方法，先判断 hashcode 是否相等，再判断是否 equals。 ArrayList 与 LinkedList 的区别和适用场景Arraylist：优点：ArrayList 是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。缺点：因为地址连续， ArrayList 要移动数据,所以插入和删除操作效率比较低。 LinkedList：优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作 add、remove，LinedList比较占优势。LinkedList 适用于 头尾操作 或 插入指定位置 的场景。缺点：因为LinkedList要移动指针,所以查询操作性能比较低。 适用场景分析：当需要对数据进行对此访问的情况下选用ArrayList；当需要对数据进行多次增加删除修改时采用LinkedList。 HashMap 和 Hashtable 的区别？ 原文链接： Javarevisited 翻译： ImportNew.com - 唐小娟译文链接： http://www.importnew.com/7010.html 这篇文章中，我们不仅将会看到HashMap和Hashtable的区别，还将看到它们之间的相似之处。 HashMap和Hashtable的区别 HashMap 和 Hashtable 都实现了 Map 接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。 HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable既不支持 Null key 也不支持 Null value)。 HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 HashMap不能保证随着时间的推移Map中的元素次序是不变的。 要注意的一些重要术语： sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。 Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。 我们能否让HashMap同步？ HashMap可以通过下面的语句进行同步：Map m = Collections.synchronizeMap(hashMap); 结论:Hashtable 和 HashMap 有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用 ConcurrentHashMap 吧。 二叉树的深度优先遍历和广度优先遍历的具体实现 ？二叉树的深度优先遍历的通用做法是采用栈，用的是栈的先进后出的特性；广度优先遍历的通用做法是采用队列，每当遍历当前节点的时候，把该节点从队列中拿出来，并且把它的子节点全部加到队列中。深度优先遍历：对每一个可能的分支路径深入到不能在深入为止，而且每个节点只能访问一次。有三种情况：先序遍历：对任一字树，先访问根，然后遍历其左子树，最后遍历其右子树中序遍历：对任一子树，先遍历其左子树，然后访问根，最后遍历其右子树后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根广度优先遍历：又叫层次遍历，从上到下对每一层依次访问，在每一层中，从左到右(也可以从右往左)访问节点，访问完一层就进入下一层，直到没有节点可以访问为止参考资料：https://blog.csdn.net/dyy_gusi/article/details/46414677 volatile 、Sychronized 关键字volatile 关键字为变量的访问提供了一种免锁机制，确保了在多线程环境下共享变量的内存可见性，意思就是线程A修改了volatile修饰的变量，线程B能够感知修改。声明变量加入volatile关键字后，每次修改该变量，JVM就会通知处理器将工作内存的值强制更新到主内存中，获取该变量时，会从主内存中获取再加载到工作内存中。 volatile与Sychronized区别：Volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。Volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的Volatile 仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性volatile 不会造成线程的阻塞；synchronized可能会造成线程的阻塞。Volatile 标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化 名词解释：原子性：一个操作要么全部执行并且执行过程不会被打断，要么就不执行。Java内存模型只保证了基本读取和赋值是原子性操作可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，另外一个变量能够立即看到修改的值有序性：程序执行的顺序按照代码的先后顺序执行，指令重排序不会影响单个线程的执行，但是会影响线程并发执行的正确性 死锁？是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。 死锁产生的原因：系统资源的竞争，进程推进顺序非法。 死锁产生的必要条件：互斥条件：一个资源每次只能被一个线程使用。请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 避免死锁：加锁顺序（线程按照一定的顺序加锁）加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）死锁检测 针对那些不可能实现按序加锁并且锁超时也不可行的场景 Java常见的编码方式ASCII码，GBK，UTF-8，UTF-16UTF-8 中文占 3 个字节，英文占 1 个字节UTF-16 中文占 4 个字节，英文占 4 个字节 基本数据类型的大小，以及封装类 Java 网络协议http 与 https 的区别 类型 原理 功能 （数据加密） 性能（安全性） 标准端口 CA证书 URL 开头 HTTP 应用层 不加密（明文传输） 不安全 80 不需 http:// HTTPS 传输层 加密（SSL加密，身份认证） 安全 443 需要 https:// http 是超文本传输协议，信息是明文传递；https 是具有安全性的ssl加密传输协议，保证交换数据的隐私与完整性。 http 和 https 网络分层与对比 HTTP HTTPS HTTP - 应用层 HTTP - 应用层 TSL/SSL - 安全层 TCP - 传输层 TCP - 传输层 IP - 网络层 IP - 网络层 网络接口 - 数据链路层 网络接口 - 数据链路层 HTTPS 备注 HTTP - 应用层 TSL/SSL - 安全层 TCP - 传输层 IP - 网络层 网络接口 - 数据链路层 TCP/IP 协议族 四层模型为什么要分层？因为网络不稳定，或者数据比较大（）对数据切块，所以需要分层。 HTTP 备注 HTTP - 应用层 上层发数据 TCP - 传输层 传东西，保证网络的稳定传输，专门只做包的分发（TCP 、UDP 都有网络的需求，所以需要再分一层），或者也可以说 拆包 IP - 网络层 用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。解析地址寻址、路由、找路由器等 网络接口 - 数据链路层 往目标地址传输数据，就是我们实际的网络（以太网、wifi）；链路层也可分为数据链路层、物理链路层（网线、交换机）。 举一个例子: 我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个Web 页面的HTTP 请求。接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。在网络层（IP 协议），增加作为通信目的地的 MAC 地址(media access control address 媒体通过控制地址,也称局域网地址,MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。)后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。 TCP 与 UDP 的区别？Tcp 面向连接，提供可靠的传输； UDP面向无连接，提供不可靠传输Tcp 提供流量控制 ； UDP不提供流量控制Tcp 保证传输数据顺序 ； UDP不保证传输顺序，也就是可能是乱序收包TCP 面向字节流 ； UDP 面向数据包补充：TCP传输控制协议，一种传输层的通信协议UDP用户数据报协议，一种传输层通信协议TCP面向连接，UDP是无连接的TCP提供可靠的服务，通过TCP传输的数据无差错，不丢失，不重复且按序到达；UDP不保证可靠交付TCP面向字节流；UDP面向报文TCP连接只能点对点；UDP支持一对一，一对多，多对一和多对多的通信TCP首部开销20字节；UDP首部开销8字节TCP的逻辑通道是全双工的可靠信道；UDP是不可靠信道 http1.0，http1.1和http2.0的区别？ 原文链接:http://blog.51cto.com/12118369/1962662 HTTP1.0 HTTP 1.1 主要区别长连接HTTP 1.0 需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。 节约带宽HTTP 1.1 支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。 这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。 HOST域现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。 HTTP1.0是没有host域的，HTTP1.1才支持这个参数。 HTTP1.1 HTTP 2.0主要区别多路复用HTTP2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。关于多路复用，可以参看学习NIO 。 数据压缩HTTP1.1 不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。 服务器推送意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。 总结： HTTP1.0 需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接； http1.1 支持只发送header，服务器返回100再发送请求 body，节省宽带流量； http1.1 断点续传； HTTP1.0 是没有host域的，HTTP1.1 才支持这个参数；（host 字段指定对应的虚拟站点） HTTP2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级； HTTP1.1 不支持header数据的压缩，HTTP2.0 使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快； HTTP2.0 支持服务端推送 浏览器输入地址到返回结果发生了什么？DNS域名解析建立TCP连接发送HTTP请求服务器处理 HTTP 请求并返回响应报文关闭TCP连接浏览器解析HTML浏览器渲染布局界面 Get 和 Post 区别？Get 与 post 都是HTTP协议中两种发送请求的方法Get 参数通过URL传递，post放在 Request body 中Get 参数直接暴露在URL中，不能传递敏感信息，不安全Get 对参数类型，长度，编码都有限制，post 没有Get 产生一个TCP数据包，post产生两个TCP数据包","categories":[{"name":"Java","slug":"java","permalink":"https://leaderliang.coding.me/categories/java/"},{"name":"面试","slug":"interview","permalink":"https://leaderliang.coding.me/categories/interview/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://leaderliang.coding.me/tags/java/"},{"name":"面试","slug":"interview","permalink":"https://leaderliang.coding.me/tags/interview/"}]},{"title":"父母是我们和死神之间的一堵墙","slug":"父母是我们和死神之间的一堵墙","date":"2018-04-19T14:11:48.000Z","updated":"2019-03-19T15:59:35.819Z","comments":true,"path":"2ef5.html","link":"","permalink":"https://leaderliang.coding.me/2ef5.html","excerpt":"父母是我们和死神之间的一堵墙","text":"父母是我们和死神之间的一堵墙，感觉视频说的挺现实的…","categories":[{"name":"视频推荐","slug":"video","permalink":"https://leaderliang.coding.me/categories/video/"}],"tags":[{"name":"视频推荐","slug":"video","permalink":"https://leaderliang.coding.me/tags/video/"},{"name":"video","slug":"video","permalink":"https://leaderliang.coding.me/tags/video/"}]},{"title":"程序员必备翻墙技能之 Shadowsocks 的使用","slug":"程序员必备翻墙技能之-Shadowsocks-的使用","date":"2018-03-11T07:58:10.000Z","updated":"2019-12-24T04:19:43.609Z","comments":true,"path":"1829.html","link":"","permalink":"https://leaderliang.coding.me/1829.html","excerpt":"作为一名合格的程序员，能够在日常开发过程中在使用搜索引擎时提高搜索效率，大家都会选择使用 Google","text":"作为一名合格的程序员，能够在日常开发过程中在使用搜索引擎时提高搜索效率，大家都会选择使用 Google，但是因为诸多原因被限制，今天就给大家推荐一个性价比极高的翻墙工具，当然如果个人有时间和能力的话，可以自己搭建一个… Shadowsocks客户端下载一流的安全性和加密，并且覆盖所有操作系统（Windows、Mac OS X、 Linux、Android、ios、OpenWRT），下载地址 Mac 的界面大致如下图，其他操作系统的可以在 Github 上自行研究。 Shadowsocks 官方服务购买客户端下载完后，需要购买他们的服务，他们的产品连接 Shadowsocks，打开后应该可以看到他们的服务购买入口 根据自己的需求选择适合自己的种类就行购买，个人推荐使用性价比最高的是云加速服务里的入门版本，主要是价格便宜啊，19.95 AUD/年，约合 94.3914 元人民币，比我之前用的便宜多了。另外每个月 50G 流量，次月清零，重新计算，其实使劲儿用一半都用不上。而且在 YouTube 上看视频也不卡呦，另外告诉大家一个小秘密，入门版上写着仅支持 1 台设备同时连接，实际上你可以巧妙的绕开呦，在这里就不多说了。 Shadowsocks 参数配置因为各个平台包括版本不同，配置方式可能也会多少有些差异，有不明白的可以在上面提到的 Github 上找一下，或者看下社区论坛，总会找到解决办法的，在这里就简单说下 Mac 上的配置。 购买后的页面长这样 点击列表里的 云加速服务 - 入门版，进入管理入门版界面，会看到自己的注册日期、续约价格、账单周期等信息，在这里主要说下快速配置。 界面往下滑可以看到类似上图的信息，点击右侧的二维码图片会显示一个二维码，别急关闭，此时点击电脑上安装的 Shadowsocks，右键或者怎么打开操作菜单，Mac 的长这样 点击扫描屏幕上的二维码，稍等一两秒，Shadowsocks 就已经自动帮你配置好了，可以点开 Shadowsocks 菜单里的 服务器配置 进行查看刚才的配置信息，当然你也可以自己手动配置，在这里就不介绍了，自行研究。 一切就绪后，就可以愉快的玩耍啦~","categories":[{"name":"Tools","slug":"tools","permalink":"https://leaderliang.coding.me/categories/tools/"}],"tags":[{"name":"Tools","slug":"tools","permalink":"https://leaderliang.coding.me/tags/tools/"},{"name":"Shadowsocks","slug":"shadowsocks","permalink":"https://leaderliang.coding.me/tags/shadowsocks/"},{"name":"翻墙","slug":"vpn","permalink":"https://leaderliang.coding.me/tags/vpn/"},{"name":"Google","slug":"google","permalink":"https://leaderliang.coding.me/tags/google/"},{"name":"VPN","slug":"vpn","permalink":"https://leaderliang.coding.me/tags/vpn/"}]},{"title":"RxJava2.0 学习笔记 - 同步和异步的理解和认识","slug":"RxJava2-0-学习笔记-同步和异步的理解和认识","date":"2017-12-24T10:06:30.000Z","updated":"2019-11-20T13:22:49.567Z","comments":true,"path":"43e5.html","link":"","permalink":"https://leaderliang.coding.me/43e5.html","excerpt":"","text":"RxJava2.0 同步、异步本文并非原创，通过各位博主博客学习后总结而得，以方便自己学习，在此感谢各位前辈，并在下面注明出处。 RxJava 同步当上下游工作在同一个线程中时, 这时候是一个同步的订阅关系, 也就是说上游每发送一个事件必须等到下游接收处理完了以后才能接着发送下一个事件。 RxJava 异步当上下游工作在不同的线程中时, 这时候是一个异步的订阅关系, 这个时候上游发送数据不需要等待下游接收, 为什么呢, 因为两个线程并不能直接进行通信, 因此上游发送的事件并不能直接到下游里去, 这个时候就需要一个田螺姑娘来帮助它们俩, 这个田螺姑娘就是水缸 ! 上游把事件发送到水缸里去, 下游从水缸里取出事件来处理, 因此, 当上游发事件的速度太快, 下游取事件的速度太慢, 水缸就会迅速装满, 然后溢出来, 最后就 OOM 了。 举例： 12345678910111213141516Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; //无限循环发事件 emitter.onNext(i); &#125; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Thread.sleep(2000); Log.d(TAG, &quot;&quot; + integer); &#125; &#125;); 这个就是上面解释的，上游发送的所有事件都放到水缸里了, 所以瞬间水缸就满了，就直接 Throwing OutOfMemoryError 掉了。 同步、异步区别从上面两图中我们可以看出, 同步和异步的区别仅仅在于是否有 水缸。源头找到了, 只要有 水缸, 就会出现上下游发送事件速度不平衡的情况, 因此当我们以后遇到这种情况时, 仔细思考一下水缸在哪里, 找到水缸, 你就找到了解决问题的办法。 避免 OOM 的几种有效果方案查看效率可以在 studio 中执行代码，然后打开 Android Monitor 或 Profiler，查看内存曲线，查看差异 上游不限制，下游控制延迟这段代码很简单, 上游同样无限循环的发送事件, 在下游每次接收事件前延时2秒. 上下游工作在同一个线程里 1234567891011121314Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; //无限循环发事件 emitter.onNext(i); &#125; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Thread.sleep(2000); Log.d(TAG, &quot;&quot; + integer); &#125; &#125;); 上游控制数据量那我们可以只放我们需要的事件到水缸里呀, 只放一部分数据到水缸里, 这样不就不会溢出来了么 123456789101112131415161718192021Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; emitter.onNext(i); &#125; &#125; &#125;).subscribeOn(Schedulers.io()) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer % 10 == 0; &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;&quot; + integer); &#125; &#125;); 在这段代码中我们增加了一个filter, 只允许能被10整除的事件通过。可以看到, 通过减少进入水缸的事件数量的确可以有效缓解上下游流速不均衡的问题, 但是力度还不是特别够。 通过 sample 操作符sample 操作符, 这个操作符每隔指定的时间就从上游中取出一个事件发送给下游。下面修改代码每隔 2 秒取一个事件给下游： 1234567891011121314151617Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; emitter.onNext(i); &#125; &#125;&#125;).subscribeOn(Schedulers.io()) /*sample取样*/ .sample(2, TimeUnit.SECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;&quot; + integer); &#125; &#125;); 通过查看曲线变化可以看到, 虽然上游仍然一直在不停的发事件, 但是我们只是每隔一定时间取一个放进水缸里, 并没有全部放进水缸里, 因此这种操作内存占有率也是很低的。第二、三这两种方法归根到底其实就是减少放进水缸的事件的数量, 是以数量取胜的。但是这个方法有个缺点, 就是丢失了大部分的事件。 减慢上游发送事件的速度既然上游发送事件的速度太快, 那我们就适当减慢发送事件的速度, 从速度上取胜。举栗： 12345678910111213141516Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; emitter.onNext(i); Thread.sleep(2000); //每次发送完事件延时2秒 &#125; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;&quot; + integer); &#125; &#125;); 上游每次发送完事件后都延时了 2 秒。查看 Profiler 内存曲线是平滑的，而且事件也没有丢失，上游通过适当的延时，不但减缓了事件进入水缸的速度，也可以让下游有充足的时间从水缸里取出事件来处理，这样一来, 就不至于导致大量的事件涌进水缸，也就不会OOM啦。 到目前为止, 我们没有依靠任何其他的工具, 就轻易解决了上下游流速不均衡的问题。 总结一下, 上面提到的治理办法就两种: 从数量上进行治理, 减少发送进水缸里的事件。 从速度上进行治理, 减缓事件发送进水缸的速度。 以上的学习，让我对如何处理上下游流速不均衡已经有了基本的认识了。Flowable 虽然也可以实现，但是这里并没有使用 Flowable, 所以很多时候仔细去分析问题, 找到问题的原因, 从源头去解决才是最根本的办法。Flowable，其实没什么神秘的, 它用到的办法和上面所讲的基本上是一样的, 只是它稍微做了点封装。","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"},{"name":"RxJava","slug":"rxjava","permalink":"https://leaderliang.coding.me/categories/rxjava/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"},{"name":"RxJava","slug":"rxjava","permalink":"https://leaderliang.coding.me/tags/rxjava/"}]},{"title":"RxJava2.0 学习笔记 - 常见操作符的使用","slug":"RxJava2-0-学习笔记-操作符的使用","date":"2017-12-20T14:56:58.000Z","updated":"2019-11-20T13:22:17.124Z","comments":true,"path":"32d4.html","link":"","permalink":"https://leaderliang.coding.me/32d4.html","excerpt":"","text":"RxJava2.0 操作符本文并非原创，通过各位博主博客学习后总结而得，以方便自己学习，在此感谢各位前辈，并在下面注明出处。 操作符目录 map flatMap concatMap zip 说明 mapmap 是 RxJava 中最简单的一个变换操作符, 它的作用就是对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化。用下面图表示： 图中 map 中的函数作用是将圆形事件转换为矩形事件, 从而导致下游接收到的事件就变为了矩形。用代码来表示为： 12345678910111213141516171819Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(&quot;234&quot;); emitter.onNext(&quot;678&quot;); emitter.onNext(&quot;456&quot;); &#125;&#125;).map(new Function&lt;String, Float&gt;() &#123; @Override public Float apply(String string) throws Exception &#123; return Float.valueOf(string); &#125;&#125;).subscribe(new Consumer&lt;Float&gt;() &#123; @Override public void accept(Float aFloat) throws Exception &#123; mRxOperatorsText.append(&quot;accept : &quot; + aFloat + &quot;\\n&quot;); Log.e(TAG, &quot;accept : &quot; + aFloat + &quot;\\n&quot;); &#125;&#125;); 在上游我们发送的是 String 类型, 而在下游我们接收的是 Float 类型, 中间起转换作用的就是 map 操作符, 运行结果为: 123E/RxUsage: accept : 234.0E/RxUsage: accept : 678.0E/RxUsage: accept : 456.0 通过 map, 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合。 flatMapflatMap 将一个发送事件的上游 Observable 变换为多个发送事件的 Observables，然后将它们发射的事件合并后放进一个单独的 Observable 里。 但有个需要注意的是，flatMap 并不能保证事件的顺序，如果需要保证顺序，需要用到下面提到的 ConcatMap。 中间flatMap的作用是将圆形的事件转换为一个发送矩形事件和三角形事件的新的上游Observable. 看看分解动作： 上游每发送一个事件，flatMap 都将创建一个新的水管, 然后发送转换之后的新的事件，下游接收到的就是这些新的水管发送的数据。这里需要注意的是，flatMap 并不保证事件的顺序，也就是图中所看到的，并不是事件 1 就固定在事件 2 的前面。如果需要保证顺序则需要使用 concatMap。 代码实现： 1234567891011121314151617181920212223242526272829303132Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125;&#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(&quot;I am value &quot; + integer); &#125; int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); &#125;&#125;).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; // 这个打印出来是不完整的，偶尔会丢失数据！！！ // 有人说 Android8.0和Android9.0 兼容性有问题了，使用 flatmap，下游无法接收到全部的消息 // 还未验证 ！！！ Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); //这个打印出来是完整的，下游不会丢失数据 mRxOperatorsText.append(&quot;stringBuffer flatMap : accept : &quot; + s + &quot;\\n&quot;); Log.e(TAG, mRxOperatorsText.toString()); &#125; &#125;); 多次打印结果： 12345678E/RxUsage: flatMap : accept : I am value 1E/RxUsage: flatMap : accept : I am value 1E/RxUsage: flatMap : accept : I am value 3E/RxUsage: flatMap : accept : I am value 3E/RxUsage: flatMap : accept : I am value 2E/RxUsage: flatMap : accept : I am value 3E/RxUsage: flatMap : accept : I am value 2E/RxUsage: flatMap : accept : I am value 2 1234567E/RxUsage: flatMap : accept : I am value 1E/RxUsage: flatMap : accept : I am value 1E/RxUsage: flatMap : accept : I am value 2E/RxUsage: flatMap : accept : I am value 2E/RxUsage: flatMap : accept : I am value 3E/RxUsage: flatMap : accept : I am value 3E/RxUsage: flatMap : accept : I am value 3 看了很多博客，显示的结果 1-3 都是完整循环多次后打印出来的，如这样： 123456789D/TAG: I am value 1D/TAG: I am value 1D/TAG: I am value 1D/TAG: I am value 3D/TAG: I am value 3D/TAG: I am value 3D/TAG: I am value 2D/TAG: I am value 2D/TAG: I am value 2 不过当使用 StringBuffer append 后结果是正常的，详细可查看代码 RxUsage/testFlatMap 有网友评论说是和手机版本有关系，还待验证…，回头验证一下！！！？？？ flatMap 在项目中的实践主要用于解决 嵌套请求 问题。 举一个是实际的例子，如果是一个新用户, 必须先注册, 等注册成功之后再去自动登录；这是一个嵌套的网络请求, 首先需要去请求注册, 待注册成功回调了再去请求登录的接口。 接口： 1234567public interface Api &#123; @GET Observable&lt;LoginResponse&gt; login(@Body LoginRequest request); @GET Observable&lt;RegisterResponse&gt; register(@Body RegisterRequest request);&#125; 可以看到登录和注册返回的都是一个上游 Observable, 而 flatMap 操作符的作用就是把一个 Observable 转换为另一个 Observable。 链式代码： 12345678910111213141516171819202122232425262728api.register(new RegisterRequest()) //发起注册请求 .subscribeOn(Schedulers.io()) //在IO线程进行网络请求 .observeOn(AndroidSchedulers.mainThread()) //回到主线程去处理请求注册结果 .doOnNext(new Consumer&lt;RegisterResponse&gt;() &#123; @Override public void accept(RegisterResponse registerResponse) throws Exception &#123; /*先根据注册的响应结果去做一些操作*/ &#125; &#125;) .observeOn(Schedulers.io()) //回到IO线程去发起登录请求 .flatMap(new Function&lt;RegisterResponse, ObservableSource&lt;LoginResponse&gt;&gt;() &#123; @Override public ObservableSource&lt;LoginResponse&gt; apply(RegisterResponse registerResponse) throws Exception &#123; return api.login(new LoginRequest()); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) //回到主线程去处理请求登录的结果 .subscribe(new Consumer&lt;LoginResponse&gt;() &#123; @Override public void accept(LoginResponse loginResponse) throws Exception &#123; Toast.makeText(MainActivity.this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Toast.makeText(MainActivity.this, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); 再次补充： subscribeOn() 指定的是上游发送事件的线程;observeOn() 指定的是下游接收事件的线程;多次指定 上游 的线程只有第一次指定的有效, 也就是说多次调用 subscribeOn() 只有第一次的有效, 其余的会被忽略；多次指定 下游 的线程是可以的, 也就是说每调用一次 observeOn() , 下游的线程就会切换一次。 concatMap它和 flatMap 的作用几乎一模一样, 只是它的结果是严格按照上游发送的顺序来发送的, 代码如下： 12345678910111213141516171819202122232425262728293031Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125;&#125;).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(&quot;I am value &quot; + integer); &#125; int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); &#125;&#125;).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; Log.e(TAG, &quot;concatMap : accept : &quot; + s + &quot;\\n&quot;); mRxOperatorsText.append(&quot;concatMap : accept : &quot; + s + &quot;\\n&quot;); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; &#125; &#125;); 打印结果： 123456E/RxUsage: concatMap : accept : I am value 1E/RxUsage: concatMap : accept : I am value 1E/RxUsage: concatMap : accept : I am value 2E/RxUsage: concatMap : accept : I am value 2E/RxUsage: concatMap : accept : I am value 3E/RxUsage: concatMap : accept : I am value 3 结果是有序的，但是没有打印循环三次的结果？？？需要再查一下原因，更新到博客里。 zipzip 通过一个函数将多个 Observable 发送的事件结合到一起，然后发送这些组合到一起的事件。它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个 Observable 一样多的数据。 从这个图中可以看见, 这次上游和以往不同的是, 有两根水管啦。其中一根水管负责发送圆形事件, 另外一根水管负责发送三角形事件, 通过 zip 操作符, 使得圆形事件和三角形事件合并为了一个矩形事件。 分解动作： 分解动作解析：组合的过程是分别从 两根水管里各取出一个事件 来进行组合, 并且一个事件只能被使用一次, 组合的顺序是严格按照事件发送的顺利 来进行的, 也就是说不会出现圆形 1 事件和三角形 B 事件进行合并, 也不可能出现圆形 2 和三角形 A 进行合并的情况。 最终下游收到的事件数量是和上游中发送事件最少的那一根水管的事件数量相同。这个也很好理解, 因为是从每一根水管里取一个事件来进行合并, 最少的那个肯定就最先取完, 这个时候其他的水管尽管还有事件 , 但是已经没有足够的事件来组合了, 因此下游就不会收到剩余的事件了。 代码演示下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * zip 组合事件的过程就是分别从发射器 A 和发射器 B 各取出一个事件来组合，并且一个事件只能被使用一次， * 组合的顺序是严格按照事件发送的顺序来进行的，所以上面截图中，可以看到，1 永远是和 A 结合的，2 永远是和 B 结合的。 * &lt;p&gt; * 最终接收器收到的事件数量是和发送器发送事件最少的那个发送器的发送事件数目相同, getStringObservable()发送器发的事件数目最少. */public static void testZip() &#123; Observable.zip(getIntegerObservable(), getStringObservable(), new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(@NonNull Integer integer, @NonNull String s) throws Exception &#123; Log.e(TAG, &quot;s + integer : &quot; + s + integer + &quot;\\n&quot;); return s + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(&quot;zip : accept : &quot; + s + &quot;\\n&quot;); Log.e(TAG, &quot;zip : accept : &quot; + s + &quot;\\n&quot;); &#125; &#125;);&#125;private static Observable&lt;String&gt; getStringObservable() &#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception &#123; if (!e.isDisposed()) &#123; e.onNext(&quot;A&quot;); mRxOperatorsText.append(&quot;String emit : A \\n&quot;); Log.e(TAG, &quot;getStringObservable --&gt; String emit : A \\n&quot;); e.onNext(&quot;B&quot;); mRxOperatorsText.append(&quot;String emit : B \\n&quot;); Log.e(TAG, &quot;getStringObservable --&gt; String emit : B \\n&quot;); e.onNext(&quot;C&quot;); mRxOperatorsText.append(&quot;String emit : C \\n&quot;); Log.e(TAG, &quot;getStringObservable --&gt; String emit : C \\n&quot;); &#125; &#125; &#125;);&#125;private static Observable&lt;Integer&gt; getIntegerObservable() &#123; return Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; if (!e.isDisposed()) &#123; e.onNext(1); mRxOperatorsText.append(&quot;Integer emit : 1 \\n&quot;); Log.e(TAG, &quot;getIntegerObservable --&gt; Integer emit : 1 \\n&quot;); e.onNext(2); mRxOperatorsText.append(&quot;Integer emit : 2 \\n&quot;); Log.e(TAG, &quot;getIntegerObservable --&gt; Integer emit : 2 \\n&quot;); e.onNext(3); mRxOperatorsText.append(&quot;Integer emit : 3 \\n&quot;); Log.e(TAG, &quot;getIntegerObservable --&gt; Integer emit : 3 \\n&quot;); e.onNext(4); mRxOperatorsText.append(&quot;Integer emit : 4 \\n&quot;); Log.e(TAG, &quot;getIntegerObservable --&gt; Integer emit : 4 \\n&quot;); e.onNext(5); mRxOperatorsText.append(&quot;Integer emit : 5 \\n&quot;); Log.e(TAG, &quot;getIntegerObservable --&gt; Integer emit : 5 \\n&quot;); &#125; &#125; &#125;);&#125; 运行结果，log 日志： 1234567891011121314E/RxUsage: getIntegerObservable --&gt; Integer emit : 1 E/RxUsage: getIntegerObservable --&gt; Integer emit : 2 E/RxUsage: getIntegerObservable --&gt; Integer emit : 3 E/RxUsage: getIntegerObservable --&gt; Integer emit : 4 E/RxUsage: getIntegerObservable --&gt; Integer emit : 5 E/RxUsage: s + integer : A1E/RxUsage: zip : accept : A1E/RxUsage: getStringObservable --&gt; String emit : A E/RxUsage: s + integer : B2E/RxUsage: zip : accept : B2E/RxUsage: getStringObservable --&gt; String emit : B E/RxUsage: s + integer : C3E/RxUsage: zip : accept : C3E/RxUsage: getStringObservable --&gt; String emit : C 一开始看到这个日志，我自己也有很多疑问，比如为什么感觉是水管一（getIntegerObservable） 发送完了之后, 水管二（getStringObservable）才开始发送呢？？ 因为我们两根水管都是运行在同一个线程里, 同一个线程里执行代码肯定有先后顺序的。因此我们来稍微改一下, 不让他们在同一个线程，为了效果更明显，需要添加延迟 Thread.sleep(1000); , 试试效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public static void testZip() &#123; Observable.zip(getIntegerObservable(), getStringObservable(), new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(@NonNull Integer integer, @NonNull String s) throws Exception &#123; Log.e(TAG, &quot;s + integer : &quot; + s + integer + &quot;\\n&quot;); return s + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(&quot;zip : accept : &quot; + s + &quot;\\n&quot;); Log.e(TAG, &quot;zip : accept : &quot; + s + &quot;\\n&quot;); &#125; &#125;);&#125; private static Observable&lt;String&gt; getStringObservable() &#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception &#123; if (!e.isDisposed()) &#123; Log.e(TAG, &quot;getStringObservable --&gt; String emit : A \\n&quot;); mRxOperatorsText.append(&quot;String emit : A \\n&quot;); e.onNext(&quot;A&quot;); Thread.sleep(1000); Log.e(TAG, &quot;getStringObservable --&gt; String emit : B \\n&quot;); mRxOperatorsText.append(&quot;String emit : B \\n&quot;); e.onNext(&quot;B&quot;); Thread.sleep(1000); Log.e(TAG, &quot;getStringObservable --&gt; String emit : C \\n&quot;); mRxOperatorsText.append(&quot;String emit : C \\n&quot;); e.onNext(&quot;C&quot;); Thread.sleep(1000); Log.e(TAG, &quot;e getStringObservable onComplete&quot;); e.onComplete(); &#125; &#125; &#125;).subscribeOn(Schedulers.io());&#125;private static Observable&lt;Integer&gt; getIntegerObservable() &#123; return Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; if (!e.isDisposed()) &#123; Log.e(TAG, &quot;getIntegerObservable --&gt; Integer emit : 1 \\n&quot;); mRxOperatorsText.append(&quot;Integer emit : 1 \\n&quot;); e.onNext(1); Thread.sleep(1000); Log.e(TAG, &quot;getIntegerObservable --&gt; Integer emit : 2 \\n&quot;); mRxOperatorsText.append(&quot;Integer emit : 2 \\n&quot;); e.onNext(2); Thread.sleep(1000); Log.e(TAG, &quot;getIntegerObservable --&gt; Integer emit : 3 \\n&quot;); mRxOperatorsText.append(&quot;Integer emit : 3 \\n&quot;); e.onNext(3); Thread.sleep(1000); Log.e(TAG, &quot;getIntegerObservable --&gt; Integer emit : 4 \\n&quot;); mRxOperatorsText.append(&quot;Integer emit : 4 \\n&quot;); e.onNext(4); Thread.sleep(1000); Log.e(TAG, &quot;getIntegerObservable --&gt; Integer emit : 5 \\n&quot;); mRxOperatorsText.append(&quot;Integer emit : 5 \\n&quot;); e.onNext(5); Thread.sleep(1000); Log.e(TAG, &quot;e getIntegerObservable onComplete&quot;); e.onComplete(); &#125; &#125; &#125;).subscribeOn(Schedulers.io());&#125; 在展示打印结果之前，上面的操作会报下面这个异常。 异常打印： 123456789101112131415161718192021W/System.err: io.reactivex.exceptions.UndeliverableException: The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What&apos;s-different-in-2.0#error-handling | java.lang.InterruptedExceptionW/System.err: at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)W/System.err: at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.onError(ObservableCreate.java:73)W/System.err: at io.reactivex.internal.operators.observable.ObservableCreate.subscribeActual(ObservableCreate.java:43)W/System.err: at io.reactivex.Observable.subscribe(Observable.java:12267)W/System.err: at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)W/System.err: at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578)W/System.err: at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)W/System.err: at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)W/System.err: at java.util.concurrent.FutureTask.run(FutureTask.java:266)W/System.err: at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301)W/System.err: at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)W/System.err: at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)W/System.err: at java.lang.Thread.run(Thread.java:764)W/System.err: Caused by: java.lang.InterruptedExceptionW/System.err: at java.lang.Thread.sleep(Native Method)W/System.err: at java.lang.Thread.sleep(Thread.java:373)W/System.err: at java.lang.Thread.sleep(Thread.java:314)W/System.err: at com.android.rxjavaproject.RxUsage$28.subscribe(RxUsage.java:458)W/System.err: at io.reactivex.internal.operators.observable.ObservableCreate.subscribeActual(ObservableCreate.java:40)W/System.err: ... 10 more 解决方法是把 Thread.sleep() 替换为 SystemClock.sleep()，下面展示打印结果。 修改后的 gif 打印：(gif 更新与 2019 年…) 使用 Thread.sleep() 时候，可能细心点的朋友又看出端倪了, getIntegerObservable 这个水管明明发送了五条个数据 + 一个 Complete, 之前不加 Thread.sleep() 明明还有的, 为啥到这里没了呢? 这是因为 zip 发送的事件数量跟上游中发送事件最少的那一根水管的事件数量是有关的, 在这个例子里我们getStringObservable 这根水管只发送了三个事件然后就发送了Complete, 这个时候尽管另外一根水管还有事件4、5 onComplete 没有发送, 但是它们发不发送还有什么意义呢?下游的打印输出里也不会输出的！ 另外使用 SystemClock.sleep() 的时候，getIntegerObservable 水管中的事件 4、5 和 onComplete 也都打印了，但是下游的 accept 中是不会接受的。 详细 demo 代码 RxUsage -&gt; testZip() zip 在项目实践场景：比如一个界面需要展示用户的一些信息, 而这些信息分别要从两个服务器接口中获取, 而只有当两个都获取到了之后才能进行展示, 这个时候就可以用Zip了。 首先分别定义这两个请求接口: 12345678public interface Api &#123; @GET Observable&lt;UserBaseInfoResponse&gt; getUserBaseInfo(@Body UserBaseInfoRequest request); @GET Observable&lt;UserExtraInfoResponse&gt; getUserExtraInfo(@Body UserExtraInfoRequest request);&#125; 接着用Zip来打包请求: 12345678910111213141516171819Observable&lt;UserBaseInfoResponse&gt; observable1 = api.getUserBaseInfo(new UserBaseInfoRequest()) .subscribeOn(Schedulers.io());Observable&lt;UserExtraInfoResponse&gt; observable2 = api.getUserExtraInfo(new UserExtraInfoRequest()) .subscribeOn(Schedulers.io());Observable.zip(observable1, observable2, new BiFunction&lt;UserBaseInfoResponse, UserExtraInfoResponse, UserInfo&gt;() &#123; @Override public UserInfo apply(UserBaseInfoResponse baseInfo, UserExtraInfoResponse extraInfo) throws Exception &#123; return new UserInfo(baseInfo, extraInfo); &#125;&#125;).observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;UserInfo&gt;() &#123; @Override public void accept(UserInfo userInfo) throws Exception &#123; //do something; &#125; &#125;); filter在这段代码中增加了一个filter,过滤一些条件，只允许被过滤后的事件通过举栗： 123456789101112131415161718192021Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; emitter.onNext(i); &#125; &#125;&#125;).subscribeOn(Schedulers.io()) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer % 10 == 0; &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;&quot; + integer); &#125; &#125;); 在这段代码中我们增加了一个 filter, 只允许能被 10 整除的事件通过。 sample 操作符sample 操作符, 这个操作符每隔指定的时间就从上游中取出一个事件发送给下游。下面代码每隔 2 秒取一个事件给下游： 1234567891011121314151617Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; emitter.onNext(i); &#125; &#125;&#125;).subscribeOn(Schedulers.io()) /*sample取样*/ .sample(2, TimeUnit.SECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;&quot; + integer); &#125; &#125;); 说明本文并非原创，通过各位博主博客学习后总结而得，以方便自己学习，在此感谢各位前辈，并在下面注明出处。 https://www.jianshu.com/u/c50b715ccaeb https://www.jianshu.com/p/a93c79e9f689","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"},{"name":"RxJava","slug":"rxjava","permalink":"https://leaderliang.coding.me/categories/rxjava/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"},{"name":"RxJava","slug":"rxjava","permalink":"https://leaderliang.coding.me/tags/rxjava/"}]},{"title":"RxJava2.0 学习笔记 - 常用关键字解释、线程调度的使用","slug":"RxJava2-0-学习笔记-关键字解释、线程调度的使用","date":"2017-12-17T13:56:58.000Z","updated":"2019-11-20T13:25:05.906Z","comments":true,"path":"10cc.html","link":"","permalink":"https://leaderliang.coding.me/10cc.html","excerpt":"","text":"RxJava2.0本文并非原创，通过各位博主博客学习后总结而得，以方便自己学习，在此感谢各位前辈，并在下面注明出处。 ObservableEmitter、Disposable、subscribe() 解释ObservableEmitterEmitter 是发射器的意思，那就很好猜了，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用 emitter 的 onNext(T value)、onComplete() 和 onError(Throwable error) 就可以分别发出 next 事件、complete 事件和 error 事件。 注意，并不意味着可以随意发射乱七八糟的事件，需要满足一定的规则： 上游可以发送无限个 onNext, 下游也可以接收无限个 onNext. 当上游发送了一个 onComplete 后, 上游 onComplete 之后的事件将会继续发送, 而下游收到 onComplete 事件之后将不再继续接收事件. 当上游发送了一个 onError 后, 上游 onError 之后的事件将继续发送, 而下游收到 onError 事件之后将不再继续接收事件. 上游可以不发送 onComplete 或 onError. 最为关键的是 onComplete 和 onError 必须唯一并且互斥, 即不能发多个 onComplete, 也不能发多个 onError, 也不能先发一个 onComplete, 然后再发一个 onError, 反之亦然 注: 关于 onComplete 和 onError 唯一并且互斥这一点, 是需要自行在代码中进行控制, 如果你的代码逻辑中违背了这个规则, 并不一定会导致程序崩溃. 比如发送多个onComplete是可以正常运行的, 依然是收到第一个 onComplete 就不再接收了, 但若是发送多个 onError, 则收到第二个 onError 事件会导致程序会崩溃， 代码仓库里 里都有写出。 Disposable单词的字面意思是一次性用品,用完即可丢弃的. 那么在RxJava中怎么去理解它呢, 对应于上面的水管的例子, 我们可以把它理解成两根管道之间的一个机关, 当调用它的 dispose() 方法时, 它就会将两根管道切断, 从而导致下游收不到事件. 注意: 调用 dispose() 并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件. subscribe()subscribe 有好几个重载方法 123456public final Disposable subscribe() &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) &#123;&#125; public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123;&#125;public final void subscribe(Observer&lt;? super T&gt; observer) &#123;&#125; 最后一个带有 Observer 参数的在 RxUsage 中的 commonUsageForChain（）已使用过； 不带任何参数的 subscribe() 表示下游不关心任何事件,你上游尽管发你的数据去吧, 下游可不关心你发什么； 带有一个 Consumer 参数的方法表示下游只关心 onNext 事件, 其他的事件我假装没看见, 因此我们如果只需要 onNext 事件可以这么写； 其他几个方法同理, 这里就不解释啦，下面示例已列出。 12345678910111213141516171819202122232425Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, &quot;emitter 1&quot;); emitter.onNext(1); Log.d(TAG, &quot;emitter 2&quot;); emitter.onNext(2); Log.d(TAG, &quot;emitter 3&quot;); emitter.onNext(3); Log.d(TAG, &quot;emitter complete&quot;); emitter.onComplete(); Log.d(TAG, &quot;emitter 4&quot;); emitter.onNext(4); &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;onNext: &quot; + integer); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; &#125; &#125;...); RxJava 强大的线程控制之线程调度上下游默认是在同一个线程工作在主线程中分别创建上游和下游, 然后将他们连接在一起, 同时分别打印出它们所在的线程 1234567891011121314151617181920212223@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName()); Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); &#125; &#125;); Consumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName()); Log.d(TAG, &quot;onNext: &quot; + integer); &#125; &#125;; observable.subscribe(consumer);&#125; 运行结果为: 1234E/RxUsage: TAG: Observable thread is : mainE/RxUsage: TAG: emit 1 E/RxUsage: TAG: Observer thread is :main E/RxUsage: TAG: onNext: 1 在子线程中做耗时的操作, 然后回到主线程中来操作 UI 黄色水管表示子线程, 深蓝色水管表示主线程;我们需要先改变上游发送事件的线程, 让它在子线程中发送事件, 然后再改变下游的线程, 让它去主线程接收事件. 通过 RxJava 内置的线程调度器可以轻松做到这一点。 12345678910111213141516171819202122public static void testPrintThreadName()&#123; Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName()); Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); &#125; &#125;); Consumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName()); Log.d(TAG, &quot;onNext: &quot; + integer); &#125; &#125;; observable.subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(consumer);&#125; 1234E/RxUsage: Observable thread is : RxNewThreadScheduler-1E/RxUsage: emit 1E/RxUsage: Observer thread is :mainE/RxUsage: onNext: 1 从打印结果可以看出, 上游发送事件的线程的确改变了, 是在一个叫 RxNewThreadScheduler-1 的线程中发送的事件, 而下游仍然在主线程中接收事件,这就完美实现了在 Android 中在子线程中做完耗时操作，然后在主线程更新 UI 的操作。 切换线程主要通过以下两行操作来实现的 12.subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) subscribeOn() 指定的是上游发送事件的线程；observeOn() 指定的是下游接收事件的线程； 补充： 多次指定 上游 的线程只有第一次指定的有效, 也就是说多次调用 subscribeOn() 只有第一次的有效, 其余的会被忽略；多次指定 下游 的线程是可以的, 也就是说每调用一次 observeOn() , 下游的线程就会切换一次。 为上面补充举个例子，方法见 RxUsage.java - testPrintThreadNameMoreChange（） 12345observable.subscribeOn(Schedulers.newThread()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .observeOn(Schedulers.io()) .subscribe(consumer); 上下游分别指定了两次发送事件的线程，上游分别是newThread和IO线程, 下游分别是main和IO线程。结果如下： 1234E/RxUsage: Observable thread is : RxNewThreadScheduler-1E/RxUsage: emit 1E/RxUsage: Observer thread is :RxCachedThreadScheduler-2E/RxUsage: onNext: 1 可以看到, 上游虽然指定了两次线程, 但只有第一次指定的有效, 依然是在 RxNewThreadScheduler 线程中, 而下游则在 RxCachedThreadScheduler 中, 这个 CacheThread 就是IO线程池中的一个。 可以通过 doOnNext（）清晰的看到下游的线程切换过程, 打印 log 1234567891011121314151617observable.subscribeOn(Schedulers.newThread()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.e(TAG, &quot;After observeOn(mainThread), current thread is: &quot; + Thread.currentThread().getName()); &#125; &#125;) .observeOn(Schedulers.io()) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.e(TAG, &quot;After observeOn(io), current thread is: &quot; + Thread.currentThread().getName()); &#125; &#125;) .subscribe(consumer); 上下游线程切换之后, 把当前的线程打印出来, 运行结果: 12345678E/RxUsage: Observable thread is : RxNewThreadScheduler-1E/RxUsage: emit 1E/RxUsage: After subscribeOn(newThread), current thread is: RxNewThreadScheduler-1E/RxUsage: After subscribeOn(io), current thread is: RxNewThreadScheduler-1E/RxUsage: After observeOn(mainThread), current thread is: mainE/RxUsage: After observeOn(io), current thread is: RxCachedThreadScheduler-2E/RxUsage: Observer thread is :RxCachedThreadScheduler-2E/RxUsage: onNext: 1 可以看到, 每调用一次 subscribeOn 和 observeOn() 线程都会切换一次, 项目中如果有有类似的需求时, 可灵活处理。 在 RxJava 中, 内置的线程： Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作 Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作 Schedulers.newThread() 代表一个常规的新线程 AndroidSchedulers.mainThread() 代表Android的主线程 在 RxJava 内部使用的是线程池来维护这些线程, 效率相对比较高. RxJava 在 Android 中的实践对于 Android 开发来说, 经常会将一些耗时的操作放在后台, 比如网络请求或者读写文件,操作数据库等等,等到操作完成之后回到主线程去更新 UI 这样的场景经常用到。 要使用 Retrofit,先添加 Gradle 配置: 1234567891011121314/*RxJava*/implementation &apos;io.reactivex.rxjava2:rxjava:2.2.8&apos;implementation &apos;io.reactivex.rxjava2:rxandroid:2.1.1&apos;/*retrofit*/implementation &apos;com.squareup.retrofit2:retrofit:2.5.0&apos;/*Gson converter*/implementation &apos;com.squareup.retrofit2:converter-gson:2.5.0&apos;/*RxJava2 Adapter*/implementation &apos;com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0&apos;/*okHttp*/implementation &apos;com.squareup.okhttp3:okhttp:3.12.0&apos;implementation &apos;com.squareup.okhttp3:logging-interceptor:3.9.0&apos;/*fastJson*/implementation &apos;com.alibaba:fastjson:1.2.56&apos; 具体操作可点击查看代码,主要有这几个类，另外使用了 api.github 接口： GithubService.java Repo.java RetrofitClient 都统一在 MainActivity 中进行调用。 看似很完美, 但我们忽略了一点, 如果在请求的过程中 Activity 已经退出了, 这个时候如果回到主线程去更新 UI, 那么APP肯定就崩溃了, 可以往上翻 Disposable , 说它是个开关, 调用它的dispose()方法时就会切断水管, 使得下游收不到事件, 既然收不到事件, 那么也就不会再去更新UI了. 因此我们可以在 Activity 中将这个 Disposable 保存起来, 当 Activity退出时, 切断它即可。 那如果有多个 Disposable 该怎么办呢, RxJava 中已经内置了一个容器 CompositeDisposable, 每当我们得到一个 Disposable 时就调用 CompositeDisposable.add() 将它添加到容器中, 在退出的时候, 调用 CompositeDisposable.clear() 即可切断所有的水管。 说明本文并非原创，通过各位博主博客学习后总结而得，以方便自己学习，在此感谢各位前辈，并在下面注明出处。 https://www.jianshu.com/u/c50b715ccaeb https://www.jianshu.com/p/a93c79e9f689","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"},{"name":"RxJava","slug":"rxjava","permalink":"https://leaderliang.coding.me/categories/rxjava/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"},{"name":"RxJava","slug":"rxjava","permalink":"https://leaderliang.coding.me/tags/rxjava/"}]},{"title":"服务器上的 Git - 生成 SSH 公钥以及多个用户使用同一台电脑生成多个 SSH 密钥","slug":"服务器上的 Git - 生成 SSH 公钥以及多个用户使用同一台电脑生成多个 SSH 密钥","date":"2017-06-12T05:55:18.000Z","updated":"2019-03-11T15:40:02.056Z","comments":true,"path":"ca0a.html","link":"","permalink":"https://leaderliang.coding.me/ca0a.html","excerpt":"SSH Key 是一种方法来确定受信任的计算机，从而实现免密码登录","text":"SSH Key 是一种方法来确定受信任的计算机，从而实现免密码登录。Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。 生成 SSH 公钥大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看： 123➜ ~ cd .ssh➜ .ssh lsid_rsa id_rsa.pub known_hosts 关键是看有没有用 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。假如没有这些文件，或者干脆连 .ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里： 123456789101112131415161718192021➜ .ssh ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/Users/liangyanqiao/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /Users/liangyanqiao/.ssh/id_rsa.Your public key has been saved in /Users/liangyanqiao/.ssh/id_rsa.pub.The key fingerprint is:SHA256:Zx+P**************************************mKyhnXOieS4 liangyanqiao@liangyanqiaodeMacBook-Pro.localThe key&apos;s randomart image is:+---[RSA 2048]----+| . || o || . . . || . o . . || ..o= S = . || . +o+.=.= o + || o +. =+.ooo.+.. ||E.B .o.o+oo*oo. ||o=.+ ooo oo*= |+----[SHA256]-----+ 首先确保在终端里面已经进入 .ssh 目录下，然后执行命令 ssh-keygen，它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空，回车进行下一步，知道最后生成 RSA。 现在，所有做过这一步的用户都得把它们的公钥给你或者 Git 服务器的管理员（假设 SSH 服务被设定为使用公钥机制）。他们只需要复制 .pub 文件的内容然后发邮件给管理员。公钥的样子大致如下： 12➜ .ssh cat id_rsa.pubssh-rsa AAAAB3Nz**************************************zbzFr leaderliang@MacBook-Pro.local 关于在多个操作系统上设立相同 SSH 公钥的教程，大家可以查阅 GitHub 上有关 SSH 公钥的向导：http://github.com/guides/providing-your-ssh-key 2019.3.6 更新遇到一个问题想在自己另一台电脑上用另一个 git 账号 使用代码仓库对代码进行管理，发现 ssh 权限存在一些问题，然后就各种尝试，查看官方文档尝试配置，但是还是有些问题。最后看了 这位老哥 的配置，才弄明白，在此记录一下。 如果你已经有了一套名为 id_rsa 的公秘钥，将要生成另外一个公钥，比如 aysee ，你也可以使用任何你喜欢的名字。大致步骤如下： 生成一个新的自定义名称的公钥：12ssh-keygen -t rsa -C &quot;YOUR_EMAIL@YOUREMAIL.COM&quot; -f ~/.ssh/ayseessh-keygen -t rsa -C &quot;YOUR_EMAIL@YOUREMAIL.COM&quot; -f ~/.ssh/aysee 执行命令后，生成命名的公钥和生成默认公钥的步骤一样。 执行完成后，会在 ~/.ssh/目录下生成一个 aysee 和 aysee.pub 文件。 在 SSH 用户配置文件 ~/.ssh/config 中指定对应服务所使用的公秘钥名称，如果没有 config 文件的话就新建一个，并输入以下内容：12Host github.com www.github.com IdentityFile ~/.ssh/aysee 添加 aysee.pub 到你的 git/github 服务器网站上测试配置文件是否正常工作1ssh -T git@gitcafe.com 如果，正常的话，会出现如下提示： 1Hi USERNAME! You&apos;ve successfully authenticated, but github does not provide shell access. 如果出现如下提示，则说明有权限问题： 1Permission denied (publickey) 如果有权限问题的情况下，你对项目执行push操作的时候，会得到如下提示： 12345Warning: Permanently added the RSA host key for IP address &apos;192.30.252.129&apos; to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 多用户时出现权限问题的原因：github使用SSH与客户端连接。如果是单用户（first），生成密钥对后，将公钥保存至 GitHub ，每次连接时SSH客户端发送本地私钥（默认~/.ssh/id_rsa）到服务端验证。单用户情况下，连接的服务器上保存的公钥和发送的私钥自然是配对的。但是如果是 多用户 （first，second），我们在连接到second的帐号时，second保存的是自己的公钥，但是SSH客户端依然发送默认私钥，即first的私钥，那么这个验证自然无法通过。 解决ssh权限问题（）:通常一台电脑生成一个ssh不会有这个问题，当一台电脑生成多个ssh的时候，就可能遇到这个问题，解决步骤如下： 查看系统ssh-key代理,执行如下命令 1$ ssh-add -l 以上命令如果输出 The agent has no identities. 则表示没有代理。如果系统有代理，可以执行下面的命令清除代理: 1$ ssh-add -D 然后依次将不同的ssh添加代理，执行命令如下： 12$ ssh-add ~/.ssh/id_rsa$ ssh-add ~/.ssh/aysee 你会分别得到如下提示： 12048 8e:71:ad:88:78:80:b2:d9:e1:2d:1d:e4:be:6b:db:8e /Users/aysee/.ssh/id_rsa (RSA) 和 122048 8e:71:ad:88:78:80:b2:d9:e1:2d:1d:e4:be:6b:db:8e /Users/aysee/.ssh/id_rsa (RSA)2048 a7:f4:0d:f1:b1:76:0b:bf:ed:9f:53:8c:3f:4c:f4:d6 /Users/aysee/.ssh/aysee (RSA) 如果使用 ssh-add ~/.ssh/id_rsa的时候报如下错误，则需要先运行一下 ssh-agent bash 命令后再执行 ssh-add …等命令 1Could not open a connection to your authentication agent. 配置 /.ssh/config 文件如果没有就在/.ssh目录创建config文件，该文件用于配置私钥对应的服务器 1234567891011#Default github user(first@mail.com)Host github.comHostName github.comUser gitIdentityFile C:/Users/username/.ssh/id_rsa #aysee (company_email@mail.com)Host github-ayseeHostName github.comUser gitIdentityFile C:/Users/username/.ssh/aysee Host随意即可，方便自己记忆，后续在添加remote是还需要用到。 配置完成后，在连接非默认帐号的github仓库时，远程库的地址要对应地做一些修改，比如现在添加second帐号下的一个仓库test，则需要这样添加： 12git remote add test git@github-aysee:ay-seeing/test.git#并非原来的git@github.com:ay-seeing/test.git ay-seeing 是github的用户名 测试 ssh 1ssh -T git@github.com 你会得到如下提示，表示这个ssh公钥已经获得了权限 1Hi USERNAME! You&apos;ve successfully authenticated, but github does not provide shell access. 上一张我操作的图","categories":[{"name":"Git","slug":"git","permalink":"https://leaderliang.coding.me/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://leaderliang.coding.me/tags/git/"}]},{"title":"微信小程序学习笔记","slug":"微信小程序学习笔记","date":"2017-06-07T16:10:58.000Z","updated":"2020-06-30T06:19:32.090Z","comments":true,"path":"2da4.html","link":"","permalink":"https://leaderliang.coding.me/2da4.html","excerpt":"自从2017年1月9日，张小龙在 2017 微信公开课 Pro 上发布的小程序正式上线以来","text":"自从2017年1月9日，张小龙在 2017 微信公开课 Pro 上发布的小程序正式上线以来，小程序一直都是一个很火的话题，谁都不敢肯定的说小程序可以成为一种趋势，影响原生 APP 的市场，但小程序确实有很多自身独有的特点和优势。 最近因公司的一个小程序开发比赛，燃气了我学习小程序得热情，网上的资料也不多，学习的话也只能查阅官方提供的文档，所以想在这里记录下自己学习过程中的重点和一些开发技巧，笔记写的比较零碎，因之前没有好好学习过 JS，所以以下笔记有些理解是按照移动开发思想来写的，后期有时间会好好整理下，笔记会随着学习持续更新的，相关代码可以在我的 GitHub 上查看。 小程序的一些特点 小程序目前处于公测状态，个人开发者想获取到微信开发者账号，目前还是比较困难。 小程序适合做简单的、用完即走的应用。 小程序适合低频的应用。 小程序适合性能要求不高的应用。 小程序不支持加载 WebView。 没有小程序账号的一些限制 不能上传和发布 不能真机运行，只可以在 PC的模拟器中运行 录音、网络状态、罗盘、拨打电话等功能 无法使用 获取用户信息的流程是模拟的而不是真实的 目前小程序的这些限制，但是不影响我们学习小程序开发。 学习细节记录，关于调试扫一扫后，点击小程序本地项目 调试界面会有以 .js 和 .js[sm] 后缀结尾的文件，调试的话 要在 带有 .js[sm] 后缀的文件中打断点。 编写第一个小程序 .js javascript 文件 .json 是系统或者页面的配置文件，配置文件中不能添加注释，否则编译时候报错。 .wxml 是编写小程序的骨架文件，可以理解为 HTML 文件 .wxss 样式文件 在工程下，以 app 开头的文件属于全局配置或者样式文件。&lt;view&gt; 和 &lt;div&gt; 标签 的作用相当；只有写在 text 标签里包括的文字，才可以在手机里实现长按选中复制操作 分辨率：物理分辨率，逻辑分辨率。 page 标签可在 page 里面设置背景色，以及在状态栏里通过 windows 标签设置小程序的状态栏、导航条、标题、窗口背景色。page 标签，在样式表里书写时候不能写成 .page。 1234page&#123; height: 100%; background-color: #b3d4db;&#125; 关于小程序设计效果图：以 iphone6 的 750 个像素的宽度做效果图，假如 一个图片的像素是 200 个像素，则在小程序里 直接就写 200rpx，他们的转换关系是 1 ：1 的。 在开发过程中，水平布局的样式推荐使用 rpx 为单位，横向如果元素单一视情况也可使用 px为单位，纵向布局的间距推荐 px。 小程序实战Swiper 组件使用基础属性大家可以在官方文档中查找并使用，swiper 里有个特别的属性需要提一下 vertical=”true” 纵向滚动，使图片可以纵向滚动。 js 文件结构，和 page 页面的声明周期1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Page(&#123; /** * 页面的初始数据 */ data: &#123; // 设置数据绑定，定义数据变量 &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125;&#125;) 弹性模型/**需要先声明是弹性模型*/ display: flex; /**设置弹性模型的方向*/ flex-direction:column;数据绑定如果绑定的数据是在标签的属性上，需要添加添加双引号 “&#123;&#123; &#125;&#125;”如果绑定的数据是在标签的属性上，需要添加添加双引号 “&#123;&#123; &#125;&#125;” 如果绑定的数据在标签之间，则不需要添加 “”, eg:&lt;text&gt;&#123;&#123; &#125;&#125;&lt;/text&gt; 数据绑定扩展所有属性值是 boolean 的时候，如果有需要设置为 false 的时候，都需要写成 false 才可生效。因为如果写成 false ，小程序会默认为是有值的，从而编译为 true。 两个花括号结合起来的数据绑定也是可以生效的&lt;text&gt;&#123;&#123;data1&#125;&#125;&#123;&#123;data2&#125;&#125;&lt;/text&gt; 用 wx:if=”&#123;&#123;&#125;&#125;” 来控制 image 的显示和隐藏&lt;image&gt; wx:if=”&#123;&#123;img_visible&#125;&#125;”&gt;&lt;/image&gt; 列表渲染 wx-for(for循环)for 循环的布局样式都需要写在 &lt;block/&gt; 中，大家可以把&lt;block/&gt; 标签理解为一个大括号 {}。 12345678910111213&lt;!-- item 可以理解为条目数据的对象 index 可以理解为 索引 且 item 和 index 两个值都是 &lt;block/&gt; 标签中引用时候的默认值，可直接打 . 来调用 wx:for-item=&quot;item&quot; wx:for-index=&quot;index&quot; 这两个标签都可以不用再 &lt;block/&gt;标签中声明，直接使用 item index 打 . 调用即可。 --&gt; &lt;block wx:for=&quot;&#123;&#123;数据源或者放置数据源的 key&#125;&#125;&quot; wx:for-item=&quot;item&quot; wx:for-index=&quot;index&quot;&gt; &lt;image src=&quot;&#123;&#123;item.leaderliang.png&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;item.title&#125;&#125;&#123;&#123;index&#125;&#125;&lt;/text&gt;&lt;/block&gt; 在使用 wx:for 的时候，会报一个警告；类似于这样： 123456789./pages/post/post.wxmlNow you can provide attr &quot;wx:key&quot; for a &quot;wx:for&quot; to improve performance. | &lt;/swiper&gt; | &gt; | &lt;block wx:for=&quot;&#123;&#123;posts_key&#125;&#125;&quot; wx:for-item=&quot;item&quot; wx:for-index=&quot;index&quot;&gt; | ^ | &lt;view catchtap=&quot;onPostItemTap&quot;&gt; | &lt;!-- is = 的是模板的名字--&gt; | &lt;template is=&quot;postItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot; /&gt; 官方给的解释是这样： 123456789101112这个不是bug，是一个关于性能优化方面的提示具体参见 wx:key如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 &lt;input/&gt;中的输入内容，&lt;switch/&gt; 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。wx:key 的值以两种形式提供字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 个人尝试了下 设置 wx:key=””，暂且可以消除警告，不知道后期会不会有其他问题，随后会再研究一下。 小程序的事件机制bindtap=”方法名”view 的事件监听，但是会有冒泡的情况发生 catchtap=”方法名”可以阻止冒泡的执行 template 的使用目前 template 只支持 复用标签和样式，还不支持 js 在创建 template 后， .wxml 中会把公共的 view 布局放置进去，数据绑定的参数 item.title/date/avatar 等等属性 可以直接把 item 去掉，但是需要配合在相应 依赖的 .wxml 中把之前 设置的数据绑定处 data 的值前加 “…”,三个点，加了三个点之后，相当于把这个对象平铺了。如 1234&lt;block wx:for=&quot;&#123;&#123;posts_key&#125;&#125;&quot; wx:for-item=&quot;item&quot; wx:for-index=&quot;index&quot;&gt;&lt;!-- is = 的是模板的名字--&gt; &lt;template is=&quot;postItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot; /&gt;&lt;/block&gt; 另外在使用 template 模板的时候，需要注意，当模板里面有用到图片的地方，路径切忌不能是相对路径，要写为绝对路径，因为毕竟是模板文件，会有很多界面使用到，层级什么的会有不一样，为了避免后期不必要的 bug，建议统一使用绝对路径！ 组件自定义属性 及 获取属性在一个 view 标签里添加 catchtap 点击事件后，可以在 view 标签里添加自定义数据，通过事件传递数据。 如： 123&lt;view catchtap=&quot;onPostItemTap&quot; data-postItemId=&quot;&#123;&#123;item.postId&#125;&#125;&quot;&gt; ......&lt;/view&gt; 在 js 文件中接收 data 数据，示例代码如下： 12345onPostItemTap: function(event)&#123; var postId = event.currentTarget.dataset.postitemid; var postId = event.currentTarget.dataset.dataId; console.log(&quot;postId=&quot; + postId);&#125; event.currentTarget.dataset.dataId; event 框架提供的事件对象 currentTarget 当前点击的组件，对应的就是上面的 view currentTarget 和 target 区别target 指的是当前点击的组件currentTarget 指的是事件最终捕获的组件 dataset 所有自定义数据的集合，可以在这个集合下面寻找我们定义的数据 currentTarget、dataset 都是 Object 的。 另外在 view 标签里面定义的 data-postItemId 数据，在 onPostItemTap 事件中接收的时候 postItemId 中的连接符 和 大写的字母 都会被去掉和转换成小写，所以接收的时候，需要多注意一下。 bug 专栏另外在这里记录一下在编写小程序时候报的一些 bug： 在创建新的界面时候我们或许会把 .js、.json、.wxml、.wxss 这四个文件都给创建，但是在页面跳转的过程中，假如新创建的界面里面只有一个文本，或者没有样式和配置的时候，就会报下面这些错： 12navigateTo:fail url &quot;pages/post/post-detail/post-detail&quot; is not in app.json遇到类似于这样的就你的 系统配置文件 app.json 中没有配置 对应新创建的页面，配置一下路径就好啦。 再比如： 123pages/post/post-detail/post-detail.json未找到入口 pages/post/post-detail/post-detail.json 文件，或者文件读取失败，请检查后重新编译。遇到这样的就是因为新创建的页面的 .json 文件是空的，如果没有配置需要配置，可以在文件中写入 “&#123;&#125;”，一个大括号，就搞定啦 再或者： 12pages/post/post-detail/post-detail 出现脚本错误或者未正确调用 Page()遇到这样的，就是因为新创建的页面的 .js 文件 中需要配置一下 page 方法。 以上都是比较基础的问题，仔细看下报错日志，多试一下，再不行的话可以在官方的开发者社区搜一下相关问题，或者发起提问，基本都可以解决的。 属性解释z-indexz-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。注释：元素可拥有负的 z-index 属性值。注释：Z-index 仅能在定位元素上奏效（例如 position:absolute;）！说明：该属性设置一个定位元素沿 z 轴的位置，z 轴定义为垂直延伸到显示区的轴。如果为正数，则离用户更近，为负数则表示离用户更远 font-weight 字体的粗细123font-weight:normal;font-weight:bold;font-weight:900; 切换图片的两种方式可通过 if else 来进行设置 12&lt;image wx:if=&quot;&#123;&#123;checked&#125;&#125;&quot; catchtap=&quot;onCheckTap&quot; src=&quot;/images/icon/check.png&quot;/&gt;&lt;image wx:else catchtap=&quot;onCheckTap&quot; src=&quot;/images/icon/un_check.png&quot;/&gt; 通过数据绑定的形式 123&lt;image class=&quot;audio&quot; catchtap=&quot;onAudioTap&quot; src=&quot;&#123;&#123;isPlayingMusic ? &apos;/images/music/music-stop.png&apos; : &apos;/images/music/music-start.png&apos;&#125;&#125;&quot;&gt;&lt;/image&gt; 应用程序的生命周期123456789101112131415161718192021222324252627282930313233343536373839以下代码需要在工程根目录下的 app.js 中进行编写，目前小程序应用程序的生命周期有四个方法App(&#123; gloableData:&#123; // 音乐是否在播放 g_isPlayingMusic: false, // 哪一个音乐在播放 g_currentMusicPostId: null &#125;, /** * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） */ onLaunch: function () &#123; &#125;, /** * 当小程序启动，或从后台进入前台显示，会触发 onShow */ onShow: function (options) &#123; &#125;, /** * 当小程序从前台进入后台，会触发 onHide */ onHide: function () &#123; &#125;, /** * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息 */ onError: function (msg) &#123; &#125;&#125;) 如果我们的某个界面需要用到小程序 app.js 中的相关功能或函数，则需在相应的界面中声明一个 app 变量 12// 获取小程序实例var app = getApp(); 进而即可通过 app 变量 来调用 app.js 中对象的属性 123app.gloableData.g_isPlayingMusic = true;// 音乐播放，设置存储对应播放的 postIdapp.gloableData.g_currentMusicPostId = that.data.currentPostId; tab 选项卡tabBar如果我们的小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 12345678910111213141516171819202122232425在 app.json 文件中进行配置 tab&#123; &quot;tabBar&quot;: &#123; &quot;borderStyle&quot;: &quot;white&quot;, &quot;position&quot;: &quot;top&quot;, &quot;selectedColor&quot;: &quot;#000000&quot;, &quot;list&quot;: [ &#123; &quot;pagePath&quot;: &quot;pages/post/post&quot;, &quot;text&quot;: &quot;文章&quot;, &quot;iconPath&quot;: &quot;images/tab/yuedu.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tab/yuedu_hl.png&quot;, &quot;backgroundColor&quot;: &quot;#000000&quot;, &quot;selectedColor&quot;: &quot;#000000&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/movies/movies&quot;, &quot;text&quot;: &quot;电影&quot;, &quot;iconPath&quot;: &quot;/images/tab/dianying.png&quot;, &quot;selectedIconPath&quot;: &quot;images/tab/dianying_hl.png&quot;, &quot;backgroundColor&quot;: &quot;#000000&quot; &#125; ] &#125;&#125; tabBar 页面跳转方法 wx.switchTab(OBJECT)跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 Tip： 需要配置在 list 外边，否则无效 “borderStyle”: “white”,“position”: “top/bottom”,“selectedColor”: “#000000”,当设置 position 为 top 时，将不会显示 icontabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序 在小程序中快速创建文件和文件夹的方式1234567891011/** * 在 app.json 文件中 pages 配置项下直接编写文件路径，然后 command + s 或 (ctrl + s) * ，即可在左侧工程下生成相应的目录和文件；但目前我使用的开发版本号是 0.17.171900 * ，系统已经支持一次性创建四个文件的功能，直接在你想要的目录下新建目录即可实 */ &quot;pages&quot;: [ &quot;pages/welcome/welcome&quot;, &quot;pages/post/post&quot;, &quot;pages/movies/movies&quot;, &quot;pages/post/post-detail/post-detail&quot;], 小程序调用服务器数据12345678910111213141516171819202122232425262728293031323334353637官方示例代码wx.request(&#123; url: &apos;test.php&apos;, //仅为示例，并非真实的接口地址 data: &#123; x: &apos;&apos; , y: &apos;&apos; &#125;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;)个人实际操作时代码如下onLoad: function (options) &#123; wx.request(&#123; url: &apos;https://api.douban.com/v2/movie/top250&apos;, data: &#123;&#125;, method: &apos;GET&apos;,// 默认为 GET，有效值：OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT header: &#123; &apos;content-type&apos;: &apos;application/xml&apos; &#125;, success: function (res) &#123; console.log(res.data) &#125;, fail: function()&#123; console.log(&quot;request fail&quot;) &#125;, complete: function()&#123; &#125; &#125;) &#125; 其中填写 header 时，遇到些 bug，在这里总结下： 因为临时用的豆瓣的电影 api，在配置时 header 中按照官方示例填写如下 123header: &#123; &apos;content-type&apos;: &apos;application/json&apos;&#125;, 请求豆瓣服务器返回如下 12345GET https://api.douban.com/v2/movie/top250 400 (Bad Request)Object &#123;msg: &quot;Invalid request&quot;, code: 999, request: &quot;GET /v2/top250&quot;&#125;code:999msg:&quot;Invalid request&quot;request:&quot;GET /v2/top250&quot; 后来尝试把 vaule 修改为空字符串，或者随便的其他字符，后来多次测试发现随便改个值就可以请求成功啦。 以下是官方的一些 Bug &amp; Tip： content-type 默认为 ‘application/json’开发者工具 0.10.102800 版本，header 的 content-type 设置异常；客户端的 HTTPS TLS 版本为1.2，但 Android 的部分机型还未支持 TLS 1.2，所以请确保 HTTPS 服务器的 TLS 版本支持1.2及以下版本；要注意 method 的 value 必须为大写（例如：GET）；url 中不能有端口；request 的默认超时时间和最大超时时间都是 60s；request 的最大并发数是 5；网络请求的 referer 是不可以设置的，格式固定为 https://servicewechat.com/{appid}/{version}/page-frame.html 其中 {appid} 为小程序的 appid，{version} 为小程序的版本号，版本号为 0 表示为开发版。","categories":[{"name":"微信小程序","slug":"wechat","permalink":"https://leaderliang.coding.me/categories/wechat/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://leaderliang.coding.me/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Hexo 使用过程遇到的一些问题收集","slug":"Hexo 使用过程遇到的一些问题收集","date":"2017-06-03T06:44:12.000Z","updated":"2020-06-30T08:22:58.650Z","comments":true,"path":"e180.html","link":"","permalink":"https://leaderliang.coding.me/e180.html","excerpt":"最近因为公司统一为我们配置了新 Mac 电脑，想在新电脑上使用自己的 Hexo","text":"最近因为公司统一为我们配置了新 Mac 电脑，想在新电脑上使用自己的 Hexo，就从旧电脑上把 Hexo 文件夹全部 copy 过来了。 然后在新电脑上执行了 npm install -g hexo-cli 安装下 hexo 环境，完成以后想着部署下 Hexo，就执行了 hexo clean clean 后报了一大串异常： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Error: Module version mismatch. Expected 48, got 57. at Error (native) at Object.Module._extensions..node (module.js:597:18) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider/dtrace-provider.js:17:23) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/bunyan/lib/bunyan.js:79:18)&#123; Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos; at Function.Module._resolveFilename (module.js:469:15) at Function.Module._load (module.js:417:25) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider/dtrace-provider.js:17:23) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/bunyan/lib/bunyan.js:79:18) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos; at Function.Module._resolveFilename (module.js:469:15) at Function.Module._load (module.js:417:25) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider/dtrace-provider.js:17:23) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/bunyan/lib/bunyan.js:79:18) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) code: &apos;MODULE_NOT_FOUND&apos; &#125;INFO Deleted database.INFO Deleted public folder. 执行 hexo generate #使用 Hexo 生成静态文件 后也同样报出一串异常 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Error: Module version mismatch. Expected 48, got 57. at Error (native) at Object.Module._extensions..node (module.js:597:18) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider/dtrace-provider.js:17:23) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/bunyan/lib/bunyan.js:79:18)&#123; Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos; at Function.Module._resolveFilename (module.js:469:15) at Function.Module._load (module.js:417:25) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider/dtrace-provider.js:17:23) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/bunyan/lib/bunyan.js:79:18) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos; at Function.Module._resolveFilename (module.js:469:15) at Function.Module._load (module.js:417:25) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider/dtrace-provider.js:17:23) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/bunyan/lib/bunyan.js:79:18) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) code: &apos;MODULE_NOT_FOUND&apos; &#125;INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...[master 1cf33bb] Site updated: 2017-06-03 02:24:53 13 files changed, 103 insertions(+), 103 deletions(-) rename 2017/03/&#123;13 =&gt; 27&#125;/hello-world/index.html (93%) rewrite content.json (92%)Username for &apos;https://github.com&apos;: leaderliangPassword for &apos;https://leaderliang@github.com&apos;:To https://github.com/leaderliang/leaderliang.github.io.git a268493..1cf33bb HEAD -&gt; masterBranch master set up to track remote branch master from https://github.com/leaderliang/leaderliang.github.io.git.INFO Deploy done: git 网上搜了很多解决方案： npm install –no-optional rm -rf node_modules &amp;&amp; npm install 等等，都不好使，后来还以为是 node 的版本和之前旧电脑上的版本不一致呢，折腾了好几个版本后，发现也不是这个原因，可执行查看 node.js 版本号 node –version 最后在 github 上找到一个方案 npm rebuild 等待执行完成，在执行 clean 操作就不报异常了 总结：因每台电脑的配置不同导致生成的 node_modules 以及一些配置文件不同造成的。 Hexo 的一些功能草稿在新建文件的时候，可以先写草稿，等到写好之后，再发布出去。那么，就需要草稿的功能。 1hexo new draft &quot;新建草稿md&quot; 这样，文件就会创建在会在 source/_drafts 目录下，如果想在本地部署预览草稿，则可以使用 12345INFO Created: ~/MacDev/Hexo/source/_drafts/新建草稿文件.md# 执行hexo s --drafts或者hexo s --draft 当文章写好之后，想发布出去，就要移出草稿 123hexo publish &quot;新建草稿文件&quot;orhexo P &lt;filename&gt; 后续补充 hexo 在使用过程中出现的错误总结fs.SyncWriteStream 报错 （问题借鉴相关出处）1DeprecationWarning: fs.SyncWriteStream is deprecated 安装的node版本是8.1，而node.js从8.0开始就已经弃用了前面提到的fs.SyncWriteStream方法，然而作者项目里的一个叫hexo-fs的插件，调用了这个方法，所以就会报错，解决办法，作者没有提供，但是很显然，我只需要更新一下那个插件，就可以搞定，于是更新的方法是，在Hexo博客目录下，输入： 1npm install hexo-fs --save 等待插件更新完毕… Hexo卸载插件命令12npm uninstall 插件名 --save例如卸载七牛云同步插件 npm uninstall hexo-qiniu-sync --save DeprecationWarning: fs.SyncWriteStream is deprecatednode和hexo插件的版本带来的问题：在node8.x的版本中，fs.SyncWriteStream被弃用了 更新如下插件 1234npm install hexo-fs --savenpm install hexo-deployer-git@0.3.1 --savenpm install hexo-renderer-ejs@0.3.1 --savenpm install hexo-server@0.2.2 --save hexo 添加 gitalk 遇到的问题 有几个参数需要说一下 1234gitalk_repo: leaderliang.github.io # git repo of the hexo 创建一个与应用名称一样的repo，用来存放评论gitalk_owner: leaderliang # git repo&apos;s owner 你的github账户名gitalk_client_id: f00**********3b7ec # github app client idgitalk_client_secret: ff33*******bd0 # github app client secret 1发布的新文章提示“未找到相关的 Issues 进行评论，请联系xxx初始化创建” 解决方案，OAuth AppsHomepage URL，这里最后的/号要加，http和https没关系，都可以，因为我是https所以填了https.https://leaderliang.github.io/Authorization callback URL，也是最后的/号要加，同上https://leaderliang.github.io/ hexo 版本升级命令123456npm i hexo-cli -g同npm install hexo-cli -gnpm update输入之后发现出现了一系列的 WARN 具体可参考： https://blog.csdn.net/whjkm/article/details/81088518 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 部署代码提示 Error: Spawn failed…报错详情如下 123456789101112Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;git@github.com:leaderliang/leaderliang.github.io.git&apos;.On branch masternothing to commit, working tree cleanfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something&apos;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (/Users/liangyanqiao/MacDev/Hexo/node_modules/hexo-util/lib/spawn.js:51:21) at ChildProcess.emit (events.js:210:5) at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12) 因为在 config 文件中配置的 coding 部署地址，官网调整了，在官网找到对配置文件进行修改并对 git 远端地址修改一下即可； 12旧的：coding: git@git.dev.tencent.com:leaderliang/leaderliang.git 调整为：coding: git@e.coding.net:leaderliang/Hexo/Hexo.git Node Sass does not yet support your current environment: Windows 64-bit 异常如何解决上面的异常是在我更新了 node 版本后出现的, 这个异常直接说了 node sass 不支持当前环境，所以可以直接删掉原来不支持本机的 node sass，再重新安装就行了。 12345删除：npm uninstall --save node-sass安装：npm install --save node-sass Hexo code hight light（目前使用的不是这个，等有时间加一下）不错的 highlight.js 推荐，地址：https://highlightjs.org/usage/对应的博客简单教程：https://zihengcat.github.io/2018/03/05/Hexo博客添加highlight-js代码高亮/ ERROR Plugin load failed: hexo-generator-json-content执行命令 npm i hexo-generator-json-content -save You must install peer dependencies yourself类似以下问题 123npm WARN babel-eslint@10.0.2 requires a peer of eslint@&gt;= 4.12.1 but none is installed. You must install peer dependencies yourself.npm WARN react-flip-move@2.9.14 requires a peer of react@0.13.x || 0.14.x || 15.x.x but none is installed. You must install peer dependencies yourself.npm WARN react-flip-move@2.9.14 requires a peer of react-dom@0.13.x || 0.14.x || 15.x.x but none is installed. You must install peer dependencies yourself. 出现这样问题，原因是 npm 版本较低，更新 npm 版本即可 1npm install -g npm node 版本升级1npm install -g n 升级node.js到最新稳定版 1n stable 遇到 ermission denied 就在命令行前加 sudo was compiled against a different Node.js version using 错误问题（update 2019-11-07 19:24:49）下面把详细报错的问题展示下，可以对比下 1234567Error: The module &apos;/usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&apos;was compiled against a different Node.js version usingNODE_MODULE_VERSION 57. This version of Node.js requiresNODE_MODULE_VERSION 72. Please try re-compiling or re-installingthe module (for instance, using `npm rebuild` or `npm install`)....Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos; 出现这种问题，应该是我在搞 RN 的时候把 node 版本升级到最高了解决方法： 123456789101112# 重新安装hexohexo npm install hexo --no--optional# 如果执行上面命名后，还是提示错误，则先卸载再安装hexo npm uninstall hexo-cli -ghexo npm install hexo-cli -g# 如果发现带上前缀不好使的话，可以把 hexo 去掉，执行 npm 的命令npm install hexo --no--optionalnpm uninstall hexo-cli -gnpm install hexo-cli -g# 对写过的文章是没有影响的，放心执行 Hexo 添加 PDF 功能12345678# 安装npm install --save hexo-pdf# 在文章中添加# 外部链接：&#123;% pdf https://leaderliang.github.io/file.pdf %&#125;# 本地连接：&#123;% pdf ./pdf/kotlin_entry_study_notes.pdf %&#125; npm outdated 哪些需要更新参考： https://tommy.net.cn/2018/02/26/upgrade-hexo-to-v3-5-0/ 1234567891011121314151617181920npm outdatedPackage Current Wanted Latest Locationbabel-eslint 10.0.2 10.0.3 10.0.3 hexo-siteeslint 4.12.1 4.19.1 6.6.0 hexo-sitehexo 3.9.0 3.9.0 4.0.0 hexo-sitehexo-deployer-git 1.0.0 1.0.0 2.0.0 hexo-sitehexo-fs 1.0.2 1.0.2 2.0.0 hexo-sitehexo-generator-archive 0.1.5 0.1.5 1.0.0 hexo-sitehexo-generator-category 0.1.3 0.1.3 1.0.0 hexo-sitehexo-generator-index 0.2.1 0.2.1 1.0.0 hexo-sitehexo-generator-tag 0.2.0 0.2.0 1.0.0 hexo-sitehexo-renderer-ejs 0.3.1 0.3.1 1.0.0 hexo-sitehexo-renderer-stylus 0.3.3 0.3.3 1.1.0 hexo-sitehexo-server 0.3.3 0.3.3 1.0.0 hexo-sitehexo-util 1.4.0 1.5.0 1.5.0 hexo-sitehighlight.js 9.15.8 9.16.2 9.16.2 hexo-sitenode-sass 4.12.0 4.13.0 4.13.0 hexo-sitereact 0.14.9 0.14.9 16.11.0 hexo-sitereact-dom 0.14.9 0.14.9 16.11.0 hexo-sitereact-flip-move 2.9.14 2.10.2 3.0.4 hexo-site 把 Hexo 的版本号根据自己需要修改，其他的也根据情况更新一下。 都修改好了以后，就 npm 更新一下： 1npm install --save npm WARN ajv-keywords@2.1.1 requires a peer of ajv@^5.0.0 but none is installed. You must install peer dependencies yourself.1npm install ajv@^5.0.0 --save 必须要指定版本才可以，要不然还是会安装失败","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://leaderliang.coding.me/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://leaderliang.coding.me/tags/Hexo/"}]},{"title":"Git 的基本使用以及在使用过程中的问题解决方案整理","slug":"Git-的基本使用以及在使用过程中的问题解决方案整理","date":"2017-04-11T03:37:45.000Z","updated":"2019-03-11T15:48:11.456Z","comments":true,"path":"bc45.html","link":"","permalink":"https://leaderliang.coding.me/bc45.html","excerpt":"日常使用 Git 时基础命令和遇到很多小问题，在这里简单记录下…","text":"日常使用 Git 时基础命令和遇到很多小问题，在这里简单记录下… Git 基础命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889创建完 github 后，网站提示操作命令行echo &quot;# test&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@github.com:leaderliang/test.gitgit push -u origin mastergit remote add .../.gitgit remote remove &lt;name&gt; 多个 远端的时候，想要删除mkdir “文件夹名字” 创建文件夹touch a.md 创建文件git init 初始化 git 仓库git status 查看你当前 git 仓库的一些状态git add a.md 去操作你想要提交的文件，可以理解把想要提交的文件添加到提交的列表里 git commit -m “first commit” commit 是提交的意思，- m 代表是提交信息，执行了以上命令代表我们已经正式进行了第一次提交git log 可以查看所有产生的 commit 记录git branch 查看下当前分支情况git branch a 创建 a 分支git checkout a 切换到分支 a 上面git checkout -b a 新建一个分支 a，并且自动切换到 a 分支git merge 合并分支 ，前提是要切换到主干上在执行这个命令git branch -d a 删除 a 分支git branch -D 有些时候可能会删除失败，比如如果a分支的代码还没有合并到master，你执行 git branch -d a 是删除不了的，它会智能的提示你a分支还有未合并的代码，但是如果你非要删除，那就执 行 git branch -D a 就可以强制删除a分支git tag v1.0 给代码创建标签git checkout v1.0 切换到 v1.0 tag 的代码rm -rf .git 删除.gitls -a与GitHub 代码的相关操作命令首先需要 SSH 授权默认 Mac 默认是安装有 SSH 的在终端输入 ssh-keygen -t rsa 指定 rsa 算法生成密钥，接着连续三个回 车键（不需要输入密码），然后就会生成两个文件 id_rsa 和 id_rsa.pub ，而 id_rsa 是密钥， id_rsa.pub 就是公钥在 系统目录 ~/.ssh 下找到 .pub 文件，将内容复制到 Github 上终端输入 ssh -T git@github.com 进行测试是否授权成功如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git pushgit push -u origin mastergit push origin master 把本地代码推到远程 master 分支git pull origin master 把远程最新的代码更新到本地git 添加多个代码仓库命令#添加githubgit remote add origin https://github.com/xxx(仓库地址)#添加oschinagit remote add oschina https://git.oschina.net/xxxx(仓库地址)#提交到oschinagit push oschina master(分支名)#提交到githubgit push origin master(分支名)#从oschina更新git pull oschina master#从github更新git pull origin master上传前需要先关联远程仓库地址：git remote add origin git@github.com:leaderliang/leaderliangtest.git origin 名字可以随便取kiipu：git remote add kiipu git@git.coding.net:mycreat/kiipu-android.git kiipu 目前的关联方式git push -u kiipu master#查看我们当前项目有哪些远程仓库名称或者列表git remote -v #设置自己的用户名和邮箱（也包括 个人和企业搭建的 Git 服务器名字配置）#查看当前 git 下配置属性git config --list git config --global user.name &quot;liang&quot;git config --global user.email &quot;liang@100tal.com&quot;—-gloabl 是配置系统全局的，去掉 —-gloabl 就可以配置我们当前 git 目录下 Git 报错相关Git push 出现 “fatal: The remote end hung up unexpectedly” 解决方案在使用 git push 项目出现 “fatal: The remote end hung up unexpectedly “ 原因是 push 的文件过大 解决方案：在克隆/创建版本库生成的 .git 目录下面修改生成的 config 文件，执行如下命令： 123git config --global http.postBuffer 524288000或仅设置当前目录下git config http.postBuffer 524288000 大小自己自定义，目前为 500M，最大支持可以自己尝试下。","categories":[{"name":"Git","slug":"git","permalink":"https://leaderliang.coding.me/categories/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://leaderliang.coding.me/tags/Git/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-27T02:36:34.000Z","updated":"2019-03-11T15:47:58.985Z","comments":true,"path":"3eeb.html","link":"","permalink":"https://leaderliang.coding.me/3eeb.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://leaderliang.coding.me/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://leaderliang.coding.me/tags/Hexo/"}]},{"title":"Android Coding Style","slug":"android-coding-style","date":"2017-03-24T07:58:23.000Z","updated":"2019-03-11T15:48:56.807Z","comments":true,"path":"46bc.html","link":"","permalink":"https://leaderliang.coding.me/46bc.html","excerpt":"不错的 Android Coding Style，推荐大家在学习和开发过程中可以使用","text":"不错的 Android Coding Style，推荐大家在学习和开发过程中可以使用 转自 https://github.com/LoranWong/Android-Code-Style Table of Contents 1 Project structure 工程结构 1.1 Notice 说明 1.2 Resources directory structure 资源文件夹结构 2 Package Manner 包管理规范 2.1 General 通用 2.2 App 包结构 3 File Naming 文件命名 3.1 Class files 类文件命名 3.2 Resources files 资源文件 3.3 Drawable files 3.4 Layout files 布局文件 4 Inside Code Naming 代码内部命名 4.1 Class Variable Naming 类变量命名 4.2 Class Method Naming 类方法命名 4.3 layout.xml 布局文件变量命名 4.4 strings.xml dimens.xml colors.xml xml变量命名 4.5 额外注意 5 Code Manner 代码规范 6 Constant 内部类解析 7 Git 提交规范 1 Project structure 工程结构1.1 Notice 说明New projects should follow the Android Gradle project structure that is defined on the Android Gradle plugin user guide. The BoilerPlate project is a good reference. 新建工程需要按照最新的Android Gradle的工程结构,在以下定义：Android Gradle plugin user guide. 该工程： BoilerPlate 是一个很好的参考材料 1.2 Resources directory structure 资源文件夹结构123456res anim drawable (xml or selector) mipmap (pixel image) layout values 2 Package Manner 包管理规范2.1 General 通用1package name ： com.chuxin.[project name] 2.2 App 包结构12345678910111213141516171819* app * (class) Constant [后续有文件说明] * (class) Application* ui * fragment * activity * base * dialog * adapter * custom* service * (which servie) ...* entity * local * remote* manager * (which manager) ...* util * (which util)... 3 File Naming 文件命名3.1 Class files 类文件命名Class names are written in UpperCamelCase. For classes that extend an Android component, the name of the class should end with the name of the component; for example: SignInActivity, SignInFragment, ImageUploaderService, ChangePasswordDialog. For utilties class , the name of the class should start with its usage , and ends with Utils; for example: HttpUtils , ImageUtils 类命名方式采用 大驼峰 命名法 对于继承自安卓组件的类来说，类名应该以该组件名结尾，例如 ： SignInActivity, SignInFragment, ImageUploaderService, ChangePasswordDialog. 对于工具类来说，命名方式应该以其完成功能开始,以 Utils 结束 ，例如 ：HttpUtils , ImageUtils. 3.2 Resources files 资源文件Resources file names are written in lowercase_underscore. 资源文件以小写加下划线的方式命名 3.3 Drawable filesNaming conventions for drawables: drawable 文件的命名规范 Asset Type Prefix 前缀 Example Action bar ab_ ab_stacked.9.png Button btn_ btn_send_pressed.9.png Dialog dialog_ dialog_top.9.png Divider divider_ divider_horizontal.9.png Icon ic_ ic_star.png Menu menu_ menu_submenu_bg.9.png Notification notification_ notification_bg.9.png Tabs tab_ tab_pressed.9.png Naming conventions for icons: icons文件的命名规范 Asset Type Prefix 前缀 Example Icons ic_ ic_star.png Launcher icons ic_launcher ic_launcher_calendar.png Menu icons and Action Bar icons ic_menu ic_menu_archive.png Status bar icons ic_stat_notify ic_stat_notify_msg.png Tab icons ic_tab ic_tab_recent.png Dialog icons ic_dialog ic_dialog_info.png Naming conventions for selector states: 选择器状态文件的命名规范 State Suffix 尾缀 Example Normal _normal btn_order_normal.9.png Pressed _pressed btn_order_pressed.9.png Focused _focused btn_order_focused.9.png Disabled _disabled btn_order_disabled.9.png Selected _selected btn_order_selected.9.png 3.4 Layout files 布局文件Layout files should match the name of the Android components that they are intended for but moving the top level component name to the beginning. For example, if we are creating a layout for the SignInActivity, the name of the layout file should be activity_sign_in.xml. 布局文件的命名需要与他所嵌入的安卓组件匹配，但是将组件名称前移到开始处,例如,我们要创建一个名字为 SignInActivity, 其名字应该为 activity_sign_in.xml. Component 组件 Class Name Layout Name Activity UserProfileActivity activity_user_profile.xml Fragment SignUpFragment fragment_sign_up.xml Dialog ChangePasswordDialog dialog_change_password.xml AdapterView Item — item_person.xml 4 Inside Code Naming 代码内部命名123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081Important ： 请不要使用拼音以及数字！！！====== 常用缩写 ======完整单词 缩写Aaverage ——&gt; avgBback ——&gt; bkbackground ——&gt; bgbreak ——&gt; brkbuffer ——&gt; bufCcolor ——&gt; cr(clr)control ——&gt; ctrlDdata ——&gt; datdelete ——&gt; deldocument ——&gt; docEedit ——&gt; edterror ——&gt; errescape ——&gt; escFflag ——&gt; flgform ——&gt; frmGgrid ——&gt; grdIincrement ——&gt; incinformation ——&gt; infoinitial ——&gt; initinsert ——&gt; insimage ——&gt; imgLlabel ——&gt; lablength ——&gt; lenlist ——&gt; lstlibrary ——&gt; libMmanager ——&gt; mngr(mgr)message ——&gt; msgOOracle ——&gt; OraPpanorama ——&gt; panopassword ——&gt; pwdpicture ——&gt; picpoint ——&gt; ptposition ——&gt; posprint ——&gt; prnprogram ——&gt; prgSserver ——&gt; srvsource ——&gt; srcstatistic ——&gt; statstring ——&gt; strSybase ——&gt; SybTtemp ——&gt; tmptext ——&gt; txtUuser ——&gt; usrWwindow ——&gt; wnd(win) 4.1 Class Variable Naming 类变量命名 公有变量按 小驼峰 法命名 私有 &amp; 非静态成员变量以 m 开头 私有 &amp; 静态成员变量以 s 开头 常量以大写字母和下划线 _ 组成 尽量使用 功能/描述 + 类型 的模式 ,如 mNameTextView 类中变量的组件类型请不要使用缩写 注意不要使用 aa bb cc3 这种变态的命名方式 ！！ 类变量过多时请 分块摆放 并且 写好注释 接口类 请直接定义在类的最后 Example: 1234567891011121314public class MyClass &#123; //静态常量 public static final int SOME_CONSTANT = 42; //公有变量 public int publicField; //私有静态变量 private static MyClass sSingleton; //默认变量 int mPackagePrivate; //私有变量 private int mPrivate; //继承型变量 protected int mProtected;&#125; 4.2 Class Method Naming 类方法命名 类方法采用 小驼峰 命名法 根据函数所完成功能命名 ， 如 changView() 在函数头写对于函数功能、参数和返回值的注释，如： 12345678910/** * 获取两个数中最大的一个 * * @param value1 参与比较的第一个数 * @param value2 参与比较的第二个数 * @return 两个参数中最大的一个数 */public int max(int value1, int value2) &#123; return (value1 &gt; value2) ? value1 : value2;&#125; 一个函数请尽量保持在 50行 之内 ！！ 4.3 layout.xml 布局文件变量命名 id 以 所在组件_类型_命名 的模式，例如： @+id/main_tv_name 、 @id/chat_btn_send 布局多处重用的请使用 &lt;include&gt; 标签 所有文本请定义在 strings.xml 中 , 如 @string/app_name 重用dp请定义在 dimens.xml 中 , 如 @dimen/entry_item_height 对应组件缩写表： Component 组件 Abbreviation 缩写 Fragment fgm TextView tv ImageView iv Button btn EditText et LinearLayout ll ReleativeLayout rl normally : FirstSecond fs 4.4 strings.xml dimens.xml colors.xml xml变量命名 遵循 完整性 规范性 有序性原则 分块并注释, 将 使用在不同的 Activity 或者 Fragment 中的 xml 变量 进行分块 命名举例 ：login_error_tips in strings.xmllogin_error_tips_height in dimens.xmllogin_error_tips_bg in colors.xml Prefix 前缀 Description 描述 error_ An error message msg_ A regular information message title_ A title, i.e. a dialog title action_ An action such as “Save” or “Create” 4.5 额外注意 Good Bad XmlHttpRequest XMLHTTPRequest getCustomerId getCustomerID String url String URL long id long ID 5 Code Manner 代码规范This is good 123if (condition)&#123; body();&#125; This is bad: 1if (condition) body(); // bad! This is good: 1234&lt;TextView android:id=\"@+id/text_view_profile\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; This is bad : 123456&lt;!-- Don't do this! --&gt;&lt;TextView android:id=\"@+id/text_view_profile\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" &gt;&lt;/TextView&gt; 6 Constant 内部类解析Constant * `CODE` --&gt; `request_code`，`app_key` 等 * `CONFIG` --&gt; 项目的配置变量, 偏向于调试开发使用，如：`IS_DEBUG`, `SHOW_LOG` * `URL` --&gt; 网络地址相关 * `COUNT` --&gt; 某些约定的数字，如一次刷新显示的条目数量。__一定要有注释__ * `PATH` --&gt; 路径信息，SD卡路径等 * `KEY` --&gt; 键值对的键的信息,如 `Bundle` 中的键7 Git 提交规范基本要求 分段 例子： 1234567(Git test) Modify CircleImageView to show rounded rectanglehttps://trello.com/c/M7u5h0QAThe original function can be used normally,To show rounded rectangle, you need add param &quot;bao:round&quot; to XML file,it&apos;s value is the rounded rectangle&apos;s corner radius. 第一行: 作为标题，这在 Git 中就会做为默认显示的部分，如图中深黑色字： 第二行: 留空！因为通常在设置了邮件提醒的 Git 系统中，第二行的空行是作为分隔标题和正文的存在。 第三行: 开始就是详细说明了。可以加上对此次修改的问题的链接，或者描述。如果有用到 issue 的话可以写上 issue #[issue id]，或者附上 trello 的链接。 建议全部用英文写，其他字符有乱码的可能。 并不会乱码 粒度 说的是做的修改的粒度。如果你一天做了很多的修改，但是就只提交了一次，那么你的粒度就有点大了。 这样在你描述你的行为的时候就会显得模糊，如果你详细描述的话，提交信息会变得长篇大论。 但也不要做一点提交一点，这样粒度就会变得太小，会导致一天到晚在写提交信息，没有必要。 在我看来，这个事情真的只能凭感觉提交，用经验来做判断。因为一个BUG可能可大可小，大的话，你就得分割修复。 如果小，那么就一次提交修复就可。 粒度的掌握绝对会影响你的提交信息，因为二者是一一对应的。 宽度 是的，是宽度，不是长度。 和代码一样，如果你平时注意的话，就不要让你的代码在一行上超过80，不然谁读代码都不好受，包括你自己。 所以提交信息的宽度也有限制。 分别是标题不要超过50，内容部分不要超过70。 大概大家都会的没什么用的小Tips： 使用 git commit 命令并进入 Vim 编辑提交信息，写完后按 Esc 确保不在编辑状态，然后输入 :wq 回车退出并提交。 直接使用 Android Studio 自带的 VCS 也很方便。 参考资料： Git - 如何写好你的提交信息？ 写出好的 commit message","categories":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/categories/android/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://leaderliang.coding.me/tags/android/"}]},{"title":"Hexo Material 主题设置","slug":"Hexo-Material-主题设置","date":"2017-03-20T10:13:42.000Z","updated":"2019-03-11T15:47:50.528Z","comments":true,"path":"96e6.html","link":"","permalink":"https://leaderliang.coding.me/96e6.html","excerpt":"","text":"Material最近搭建了用 Hexo 搭建了博客，使用的 Material 主题，效果还是挺不错的，搭建的过程中遇到不少问题，一开始搭建 博客的操作，大家参考 Hexo 官网的文档基本就可搞定，在这里主要记录添加多说评论以及其他 Hexo 主题样式上遇到的问题。 多说评论为 landsape 添加评论最初搭建好博客的时候，使用的是系统默认主题 landsape ,添加多说步骤比较简单，如下： 创建多说站点后，在 Hexo 根目录下的 _config.yml 文件里添加如下配置： 1duoshuo_shortname: 你站点的 short_name 在 themes\\landscape\\layout_partial\\article.ejs 里把 1234567&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;&lt;section id=&quot;comments&quot;&gt;&lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/section&gt;&lt;% &#125; %&gt; 修改为 1234567891011121314151617181920&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = &#123;short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt;&lt;% &#125; %&gt; PS: 配置文件中 duoshuo_shortname 中的 shortname 是你创建站点后的域名的名字，eg: liang.duoshuo.com,则 shortname 就是 liang。 执行 hexo s 在本地即可查看修改效果; 为 Material 主题添加评论现在 Hexo 用的是 Material 主题，主要配置有以下两个地方： 在目录 Material 下 _config.yml 中按如下进行修改 12345comment: use: duoshuo shortname: liang duoshuo_thread_key_type: 7e70fd*********e7b6c6351 (个人基本--&gt;基本设置--&gt;密钥) duoshuo_embed_js_url: &quot;https://static.duoshuo.com/embed.js&quot; 当配置了这些后，运行本地查看多说还是没有添加上或者报关于多说的未定义 duoshuoQuery 这样的错误时，打开 layout/_partial/footer-option.ejs,把19行 123var duoshuoQuery = &#123; short_name: &apos;&lt;%= theme.comment.shortname %&gt;&apos; &#125;; 修改为 123window.duoshuoQuery = &#123; short_name: &apos;&lt;%= theme.comment.shortname %&gt;&apos; &#125;; 就可以了。 代码高亮为 Material 主题设置代码高亮目前使用的是 highlight.js 具体可点开查看多种使用方法介绍，或去简单说下我目前配置的方法，大家可作为参考。 找到 hexo 下 Material 主题的网站 HTML 入口，在 head 标签里配置你所要设置的样式文件的引用 eg: 1&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/highlight/solarized-white.css&quot; type=&quot;text/css&quot;&gt; 在 body 标签里 配置 js 文件 12345678910&lt;!-- Code hight light--&gt;&lt;script src=&quot;/js/highlight.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; hljs.initHighlightingOnLoad(); $(document).ready(function() &#123; $(&apos;.code&apos;).each(function(i, block) &#123; hljs.highlightBlock(block); &#125;); &#125;);&lt;/script&gt; 配置完成即可使用，想尝试其他方式的可查看 github 上提供的其他方式，css 样或 js 文件可在 highlight.js 查找下载使用。PS: 需要提前把 css 和 js 文件下载并放在指定路径下。","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://leaderliang.coding.me/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://leaderliang.coding.me/tags/Hexo/"}]}]}